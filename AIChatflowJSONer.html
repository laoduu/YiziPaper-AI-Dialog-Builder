<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YiziPaper AI对话模拟器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="model-config.js"></script>
    <script src="markdown-renderer.js"></script>
    <script src="save-history.js"></script>
    <script src="conversation-storage.js"></script>
    
    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'klein-blue': '#002FA7',
                        'klein-light': '#3257C5',
                        'hermes-orange': '#F3641E',
                        'hermes-light': '#FF8A4C',
                        'glass-bg': 'rgba(255, 255, 255, 0.15)',
                        'glass-bg-dark': 'rgba(17, 24, 39, 0.7)',
                        'glass-border': 'rgba(255, 255, 255, 0.2)',
                        'glass-border-dark': 'rgba(255, 255, 255, 0.1)',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    backdropBlur: {
                        'xs': '2px',
                    }
                },
            }
        }
    </script>
    
    <style>
        /* 确保对话容器不会裁剪按钮 */
        .conversation-turn {
            overflow: visible !important;
        }
        /* 确保对话内容容器不会裁剪按钮 */
        .conversation-turn > div:last-child {
            overflow: visible !important;
        }
        /* 隐藏默认的删除按钮，使用合并后的按钮组中的删除按钮 */
        /* 只隐藏绝对定位的删除按钮，不隐藏操作按钮组中的删除按钮 */
        .absolute .delete-turn {
            display: none;
        }
        /* 操作按钮样式 - 统一简单风格 */
        .action-btn {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 0.375rem;
            padding: 0.375rem;
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            height: 1.75rem;
            width: 1.75rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #1e293b;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        /* 操作按钮hover效果 - 简单效果 */
        .action-btn:hover {
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            transform: translateY(-0.125rem);
        }
        /* Dark主题操作按钮 */
        .dark .action-btn {
            background-color: rgba(51, 65, 85, 0.9);
            border: 1px solid rgba(71, 85, 105, 0.8);
            color: #e2e8f0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        /* Dark主题操作按钮hover效果 */
        .dark .action-btn:hover {
            background-color: rgba(71, 85, 105, 1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-0.125rem);
        }
        /* === 简化解决方案：确保按钮正确显示和定位 === */
        
        /* 1. 基础样式：清除所有可能的干扰 */
        * {
            box-sizing: border-box;
        }
        
        /* 2. 确保所有容器都能显示按钮，不会被裁剪 */
        .conversation-turn,
        .relative,
        .conversation-turn > div,
        .conversation-turn > div > div {
            overflow: visible !important;
        }
        
        /* 3. 按钮组基础样式 */
        .conversation-actions {
            position: absolute;
            top: 5px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 5000;
            margin: 0;
            padding: 0;
        }
        
        /* 4. 为AI助手角色设置按钮位置 */
        .conversation-turn[data-role="assistant"] .conversation-actions {
            top: 35px;
            left: -35px;
            right: auto;
        }
        
        /* 5. 为系统角色设置按钮位置 */
        .conversation-turn[data-role="system"] .conversation-actions {
            top: 35px;
            left: -35px;
            right: auto;
        }
        
        /* 6. 为用户角色设置按钮位置 */
        .conversation-turn[data-role="user"] .conversation-actions {
            top: 35px;
            left: -35px;
            right: auto;
        }
        
        /* 7. 点击文本框时显示按钮组 - 最高优先级 */
        .conversation-turn.expanded .conversation-actions {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* === 恢复优雅的滚动条设计：默认隐藏，hover显示 === */
        /* 将完整的scrollbar-hide样式移到普通style标签中，确保在任何情况下都能生效 */
        
        /* 1. 定义scrollbar-hide类：默认隐藏滚动条，hover显示 */
        .scrollbar-hide {
            /* 默认隐藏滚动条 - Firefox */
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
            
            /* 默认隐藏滚动条 - IE/Edge */
            -ms-overflow-style: none;
            
            /* 调整内边距，避免内容被滚动条遮挡 */
            margin-right: -6px;
            padding-right: 10px;
            transition: all 0.2s ease;
        }
        
        /* 2. WebKit浏览器（Chrome/Safari）默认隐藏滚动条 */
        .scrollbar-hide::-webkit-scrollbar {
            width: 0;
            height: 0;
            transition: width 0.2s ease, height 0.2s ease;
        }
        
        /* 3. hover时显示滚动条 - WebKit浏览器 */
        .scrollbar-hide:hover::-webkit-scrollbar {
            width: 6px;  /* 显示垂直滚动条 */
            height: 0;   /* 始终隐藏横向滚动条 */
        }
        
        /* 4. hover时显示滚动条 - Firefox */
        .scrollbar-hide:hover {
            scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
        }
        
        /* 5. 滚动条轨道样式 */
        .scrollbar-hide::-webkit-scrollbar-track {
            background: transparent;
        }
        
        /* 6. 滚动条滑块样式 - 默认透明 */
        .scrollbar-hide::-webkit-scrollbar-thumb {
            background-color: transparent;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        
        /* 7. hover时滑块样式 - WebKit浏览器 */
        .scrollbar-hide:hover::-webkit-scrollbar-thumb {
            background-color: rgba(156, 163, 175, 0.5);
        }
        
        /* 8. 滑块hover样式 - WebKit浏览器 */
        .scrollbar-hide::-webkit-scrollbar-thumb:hover {
            background-color: rgba(156, 163, 175, 0.7);
        }
        
        /* 9. Dark主题 - hover时滚动条颜色 - Firefox */
        .dark .scrollbar-hide:hover {
            scrollbar-color: rgba(243, 100, 30, 0.5) transparent;
        }
        
        /* 10. Dark主题 - hover时滑块颜色 - WebKit浏览器 */
        .dark .scrollbar-hide:hover::-webkit-scrollbar-thumb {
            background-color: rgba(243, 100, 30, 0.5);
        }
        
        /* 11. Dark主题 - 滑块hover颜色 - WebKit浏览器 */
        .dark .scrollbar-hide::-webkit-scrollbar-thumb:hover {
            background-color: rgba(243, 100, 30, 0.7);
        }
        
        /* 12. 确保对话容器的基本滚动功能 */
        #conversation-container {
            overflow-y: auto !important;
            overflow-x: hidden !important;
            max-height: 70vh !important;
        }
    </style>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .glass-effect {
                background: rgba(255, 255, 255, 0.9);
                border: 1px solid rgba(255, 255, 255, 0.5);
                backdrop-filter: blur(16px);
                -webkit-backdrop-filter: blur(16px);
                box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
                transition: all 0.3s ease;
            }
            .glass-effect:hover {
                background: rgba(255, 255, 255, 0.95);
                border-color: rgba(255, 255, 255, 0.7);
                box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.2);
            }
            .glass-effect-dark {
                background: theme('colors.glass-bg-dark');
                border: 1px solid theme('colors.glass-border-dark');
                backdrop-filter: blur(16px);
                -webkit-backdrop-filter: blur(16px);
                box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
                transition: all 0.3s ease;
            }
            .glass-effect-dark:hover {
                background: rgba(17, 24, 39, 0.8);
                border-color: rgba(255, 255, 255, 0.15);
                box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.4);
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            .liquid-transition {
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            .input-focus {
                @apply focus:border-klein-blue focus:ring-2 focus:ring-klein-blue/20 focus:outline-none;
            }
            .dark .input-focus {
                @apply focus:border-hermes-orange focus:ring-2 focus:ring-hermes-orange/20;
            }
            /* 统一输入元素样式 */
            .glass-input {
                background-color: rgba(206, 226, 255, 0.3);
                backdrop-filter: blur(16px);
                border: 1px solid rgba(197, 197, 255, 0.5);
                border-radius: 0.5rem;
                padding: 0.5rem;
                font-size: 0.875rem;
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
                width: 100%;
                color: #1e293b;
            }
            /* 单行输入元素样式（input, select） */
            .glass-input:not(textarea) {
                height: 2.25rem;
                display: inline-flex;
                align-items: center;
            }
            /* textarea特殊处理 */
            .glass-input:is(textarea) {
                min-height: 80px;
                resize: vertical;
                display: block;
                align-items: flex-start;
            }
            .glass-input:hover {
                background-color: rgba(255, 255, 255, 0.5);
                border-color: rgba(255, 255, 255, 0.7);
                color: #002FA7;
                box-shadow: 0 10px 15px -3px rgba(171, 172, 255, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            }
            .glass-input:focus {
                outline: none;
                border-color: #002FA7;
                box-shadow: 0 10px 15px -3px rgba(171, 172, 255, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05), 0 0 0 2px rgba(0, 47, 167, 0.2);
            }
            /* Dark主题glass-input */
            .dark .glass-input {
                background-color: rgba(51, 65, 85, 0.6);
                border-color: rgba(71, 85, 105, 0.7);
                color: #f8fafc;
            }
            .dark .glass-input:hover {
                background-color: rgba(71, 85, 105, 0.8);
                border-color: rgba(100, 116, 139, 0.9);
                color: #F3641E;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            }
            .dark .glass-input:focus {
                border-color: #F3641E;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05), 0 0 0 2px rgba(243, 100, 30, 0.2);
            }
            /* 液态玻璃风格按钮 - 统一设计 */
            .glass-btn {
                background-color: rgba(206, 226, 255, 0.3);
                backdrop-filter: blur(16px);
                border: 1px solid rgba(197, 197, 255, 0.5);
                border-radius: 0.5rem;
                padding: 0.5rem 0.75rem;
                font-size: 0.875rem;
                font-weight: 500;
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
                display: inline-flex;
                align-items: center;
                justify-content: center;
                white-space: nowrap;
            }
            
            /* 默认按钮文字颜色 */
            .glass-btn:not(.mode-btn) {
                color: #1e293b;
            }
            
            .dark .glass-btn:not(.mode-btn) {
                color: #f8fafc;
            }
            
            /* 模式切换按钮特殊样式 */
            .mode-btn {
                color: #64748b;
            }
            
            .dark .mode-btn {
                color: #cbd5e1;
            }
            
            /* 当滑动指示器位于编辑模式时，编辑模式按钮文字为白色 */
            #mode-slider:not([style*="translateX(100%)"]) ~ #edit-mode-btn,
            /* 当滑动指示器位于预览模式时，预览模式按钮文字为白色 */
            #mode-slider[style*="translateX(100%)"] ~ #preview-mode-btn {
                color: white !important;
            }
            
            /* 模式切换按钮hover效果 */
            .mode-btn:hover {
                color: #002FA7 !important;
            }
            
            .dark .mode-btn:hover {
                color: #F3641E !important;
            }
            
            /* 选中状态的模式切换按钮hover效果 */
            #mode-slider:not([style*="translateX(100%)"]) ~ #edit-mode-btn:hover,
            #mode-slider[style*="translateX(100%)"] ~ #preview-mode-btn:hover {
                color: white !important;
            }
            
            .dark .glass-btn {
                background-color: rgba(51, 65, 85, 0.6);
                border-color: rgba(71, 85, 105, 0.7);
                color: #f8fafc;
            }
            
            .glass-btn:hover {
                background-color: rgba(255, 255, 255, 0.5);
                border-color: rgba(255, 255, 255, 0.7);
                color: #002FA7;
                box-shadow: 0 10px 15px -3px rgba(171, 172, 255, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                transform: scale(1.05) translateY(-0.125rem);
            }
            
            .dark .glass-btn:hover {
                background-color: rgba(71, 85, 105, 0.8);
                border-color: rgba(100, 116, 139, 0.9);
                color: #F3641E;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                transform: scale(1.05) translateY(-0.125rem);
            }
            /* 按钮悬停指引效果 */
            .glass-btn-tooltip {
                @apply relative group;
            }
            .glass-btn-tooltip::after {
                @apply content-[''] absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-1 bg-slate-800/90 dark:bg-slate-700/90 text-white text-xs rounded-lg opacity-0 invisible transition-all duration-300 pointer-events-none backdrop-blur-sm;
            }
            .glass-btn-tooltip:hover::after {
                @apply opacity-100 visible mb-3;
            }
            /* 统一按钮悬停效果 */
            .btn-hover {
                @apply hover:scale-105 hover:shadow-md transition-all duration-300 transform hover:-translate-y-0.5;
            }
            .avatar-border {
                border: 2px solid rgba(255, 255, 255, 0.8);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            }
            .avatar-animation {
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }
            .avatar-animation:hover {
                transform: translateY(-3px) scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            /* 头像悬停提示 */
            .flex-shrink-0.relative:hover > div:last-child {
                opacity: 1;
                z-index: 1000;
            }
            /* 自定义滚动条样式 - 自动隐藏 */
            .scrollbar-hide {
                /* 默认隐藏滚动条 */
                -ms-overflow-style: none;
                scrollbar-width: none;
                margin-right: -6px;
                padding-right: 10px;
                transition: all 0.2s ease;
            }
            /* WebKit浏览器默认隐藏 */
            .scrollbar-hide::-webkit-scrollbar {
                width: 0;
                height: 0;
                transition: width 0.2s ease, height 0.2s ease;
            }
            /* WebKit浏览器hover显示 */
            .scrollbar-hide:hover::-webkit-scrollbar {
                width: 6px;
                height: 6px;
            }
            /* 打字机光标动画 */
            @keyframes blink {
                0%, 100% { opacity: 1; }
                50% { opacity: 0; }
            }
            .typewriter-cursor-blink {
                animation: blink 1s infinite;
            }
            /* 滚动条基础样式 - 修复垂直滚动条 */
            .scrollbar-hide::-webkit-scrollbar {
                width: 6px;  /* 垂直滚动条宽度 */
                height: 0;    /* 隐藏横向滚动条 */
                background: transparent;
            }
            
            /* 滚动条hover时显示垂直滚动条 */
            .scrollbar-hide:hover::-webkit-scrollbar {
                width: 6px;  /* hover时显示垂直滚动条 */
                height: 0;   /* 始终隐藏横向滚动条 */
            }
            
            /* 滚动条轨道样式 */
            .scrollbar-hide::-webkit-scrollbar-track {
                background: transparent;
            }
            
            /* 滚动条滑块样式 */
            .scrollbar-hide::-webkit-scrollbar-thumb {
                background-color: transparent;
                border-radius: 3px;
                transition: background-color 0.2s ease;
            }
            
            /* 滚动条hover时滑块样式 */
            .scrollbar-hide:hover::-webkit-scrollbar-thumb {
                background-color: rgba(156, 163, 175, 0.5);
            }
            
            /* 滚动条滑块hover样式 */
            .scrollbar-hide::-webkit-scrollbar-thumb:hover {
                background-color: rgba(156, 163, 175, 0.7);
            }
            
            /* Dark主题滚动条hover时滑块样式 */
            .dark .scrollbar-hide:hover::-webkit-scrollbar-thumb {
                background-color: rgba(243, 100, 30, 0.5);
            }
            
            /* Dark主题滚动条滑块hover样式 */
            .dark .scrollbar-hide::-webkit-scrollbar-thumb:hover {
                background-color: rgba(243, 100, 30, 0.7);
            }
            
            /* Firefox浏览器默认隐藏 */
            .scrollbar-hide {
                scrollbar-width: thin;
                scrollbar-color: transparent transparent;
                transition: scrollbar-color 0.2s ease;
                overflow-x: hidden;
            }
            
            /* Firefox浏览器hover显示 */
            .scrollbar-hide:hover {
                scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
            }
            
            /* Dark主题Firefox滚动条hover显示 */
            .dark .scrollbar-hide:hover {
                scrollbar-color: rgba(243, 100, 30, 0.5) transparent;
            }
            
            /* 强制隐藏横向滚动条 */
            #conversation-container {
                overflow-x: hidden;
            }
            /* 微信风格气泡 - 修复版 */
            .wechat-bubble-user {
                @apply bg-green-50 dark:bg-green-900/15 text-slate-800 dark:text-white rounded-2xl rounded-br-none p-3 max-w-[85%] shadow-md;
            }
            .wechat-bubble-assistant {
                @apply bg-yellow-50 dark:bg-yellow-900/15 text-slate-800 dark:text-white rounded-2xl rounded-bl-none p-3 max-w-[85%] shadow-md border border-slate-200 dark:border-slate-600;
            }
            .wechat-bubble-system {
                @apply bg-pink-50 dark:bg-pink-900/15 text-slate-600 dark:text-slate-300 rounded-xl p-3 max-w-[80%] shadow-sm text-sm;
            }
            /* 对话文本框展开效果 */
            .content-input {
                transition: all 0.3s ease;
                resize: none;
                overflow-y: auto;
                max-height: 500px;
            }
            .content-input:focus {
                min-height: 200px !important;
                max-height: 500px;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                transform: scale(1.02);
                background-color: white !important;
            }
            .dark .content-input:focus {
                background-color: #1f2937 !important;
            }
            /* 文本框点击展开样式 */
            .content-input:focus {
                min-height: 150px;
            }
            .content-input:focus + .absolute {
                opacity: 0;
            }
            .conversation-turn.expanded {
                position: relative;
            }
            /* 删除按钮提示文字 */
            .delete-turn + div {
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            .delete-turn:hover + div {
                opacity: 1;
            }
            /* 问号提示文字 */
            .cursor-help > div {
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            .cursor-help:hover > div {
                opacity: 1;
            }
        }
    </style>
</head>

<body class="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 liquid-transition p-4 md:p-6">
    <!-- 背景装饰元素 -->
    <div class="fixed -top-40 -left-40 w-96 h-96 bg-klein-blue/10 rounded-full blur-3xl dark:bg-klein-blue/20"></div>
    <div class="fixed top-1/3 -right-20 w-80 h-80 bg-klein-light/10 rounded-full blur-3xl dark:bg-klein-light/20"></div>
    <div class="fixed bottom-0 left-1/4 w-72 h-72 bg-klein-blue/5 rounded-full blur-3xl dark:bg-klein-blue/10"></div>
    
    <div class="max-w-7xl mx-auto relative z-10">
        <!-- 头部区域 -->
        <header class="glass-effect dark:glass-effect-dark rounded-2xl p-5 mb-6 liquid-transition">
            <div class="flex justify-between items-center">
                <div class="flex-1 text-center">
                    <h1 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-slate-800 dark:text-white text-shadow flex items-center justify-center">
                        <i class="fa fa-comments-o text-klein-blue dark:text-hermes-orange mr-3"></i>
                        YiziPaper AI对话模拟器
                    </h1>
                </div>
                <button id="theme-toggle" class="p-3 rounded-lg glass-btn text-slate-700 dark:text-slate-200">
                    <i class="fa fa-moon-o dark:hidden"></i>
                    <i class="fa fa-sun-o hidden dark:inline-block"></i>
                </button>
            </div>
            <p class="mt-2 text-center flex flex-wrap justify-center gap-2">
                <span class="bg-klein-blue/10 dark:bg-hermes-orange/20 text-klein-blue dark:text-hermes-light px-3 py-1 rounded-full text-sm font-medium">创建模拟对话</span>
                <span class="bg-klein-blue/10 dark:bg-hermes-orange/20 text-klein-blue dark:text-hermes-light px-3 py-1 rounded-full text-sm font-medium">生成结构化JSON数据</span>
                <span class="bg-klein-blue/10 dark:bg-hermes-orange/20 text-klein-blue dark:text-hermes-light px-3 py-1 rounded-full text-sm font-medium">AI实时输出</span>
                <span class="bg-klein-blue/10 dark:bg-hermes-orange/20 text-klein-blue dark:text-hermes-light px-3 py-1 rounded-full text-sm font-medium">支持多模型自定义</span>
            </p>
        </header>
        
        <!-- 左右分栏布局 -->
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- 左侧：对话编辑区域 -->
            <div class="lg:w-1/2 space-y-6">
                <!-- 主内容区域 -->
                <main class="glass-effect dark:glass-effect-dark rounded-2xl p-5 md:p-6 liquid-transition">
                    <div id="conversation-container" class="space-y-4 max-h-[70vh] overflow-y-auto pr-4 pb-4 pl-4 scrollbar-hide relative">
                        <!-- 对话条目将通过JS动态添加 -->
                    </div>
                    
                    <div class="flex justify-center gap-4 mt-8">
                <button id="add-turn" class="flex items-center gap-2 px-5 py-2.5 glass-btn">
                    <i class="fa fa-plus"></i>
                    <span>添加对话轮次</span>
                </button>
                <button id="conversation-manager" class="flex items-center gap-2 px-4 py-2 glass-btn">
                    <i class="fa fa-cog"></i>
                    <span>对话管理</span>
                </button>
                <button id="clear-all" class="flex items-center gap-2 px-4 py-2 glass-btn">
                    <i class="fa fa-trash-o"></i>
                    <span>清空所有对话</span>
                </button>
            </div>
                </main>
                
                <!-- API设置区域 -->
                <section class="glass-effect dark:glass-effect-dark rounded-2xl p-5 md:p-6 liquid-transition">
                    <h2 class="text-xl font-semibold text-slate-800 dark:text-white mb-4 flex items-center">
                        <i class="fa fa-key text-klein-blue dark:text-hermes-orange mr-2"></i>
                        API设置
                        <div class="relative ml-2 cursor-help">
                            <i class="fa fa-question-circle text-sm text-slate-500 dark:text-slate-400"></i>
                            <div class="absolute top-1/2 left-full transform -translate-y-1/2 ml-2 bg-slate-800/90 dark:bg-slate-700/90 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 transition-opacity duration-300 pointer-events-none z-5000">API密钥仅存储于本地缓存，请注意安全保管</div>
                        </div>
                    </h2>
                    
                    <div class="space-y-4 mb-4">
                <div class="grid grid-cols-1 md:grid-cols-6 gap-4">
                    <div class="md:col-span-2">
                        <label for="api-provider" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">API提供商</label>
                        <div class="flex gap-2">
                            <select id="api-provider" class="flex-1 glass-input input-focus text-slate-800 dark:text-white">
                            <option value="volcengine">火山方舟</option>
                            <option value="aliyun">阿里云百炼</option>
                            <option value="zhipu">智谱AI</option>
                            <option value="openai">OpenAI</option>
                            <option value="anthropic">Anthropic</option>
                            <option value="google">Google Gemini</option>
                        </select>
                            <button id="register-btn" class="glass-btn px-3 py-0.5 text-sm" onclick="openRegisterLink()">
                                注册
                            </button>
                        </div>
                    </div>
                    <div class="md:col-span-4">
                        <label for="model-select" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">大模型</label>
                        <select id="model-select" class="w-full glass-input input-focus text-slate-800 dark:text-white">
                            <!-- 模型列表将通过JavaScript动态生成 -->
                        </select>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex-1">
                        <label for="api-key" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">API密钥</label>
                        <div class="relative">
                            <input type="password" id="api-key" class="w-full glass-input input-focus pr-10 text-slate-800 dark:text-white" placeholder="请输入API密钥">
                            <button id="toggle-key-visibility" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 p-1.5 text-xs bg-transparent border-none">
                                <i class="fa fa-eye"></i>
                            </button>
                        </div>
                    </div>
                    <div class="flex items-end">
                        <button id="save-api-settings" class="px-5 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-save"></i>
                            <span>保存API密钥</span>
                        </button>
                    </div>
                </div>
            </div>
                </section>
            </div>
            
            <!-- 右侧：预览和结果区域 -->
            <div class="lg:w-1/2 space-y-6">
                <!-- AI输出预览区域 -->
                <section id="ai-preview-section" class="glass-effect dark:glass-effect-dark rounded-2xl p-5 md:p-6 liquid-transition">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-slate-800 dark:text-white flex items-center">
                            <i class="fa fa-eye text-green-600 dark:text-hermes-orange mr-2"></i>
                            AI输出预览
                        </h2>
                        
                        <!-- 预览模式切换 - 滑动选择样式 -->
                        <div class="relative inline-flex items-center bg-slate-100 dark:bg-slate-700 rounded-lg p-0">
                            <!-- 滑动指示器 - 默认位于预览模式 -->
                            <span id="mode-slider" class="absolute left-0 top-0 bg-klein-blue dark:bg-hermes-orange rounded-lg transition-all duration-300 transform translate-x-full w-1/2 h-full"></span>
                            <button id="edit-mode-btn" class="relative z-10 px-5 py-0.5 text-sm font-medium rounded-lg transition-all duration-300 text-slate-600 dark:text-slate-300 glass-btn mode-btn bg-transparent hover:bg-white/20 dark:hover:bg-slate-600/20">
                                <i class="fa fa-pencil mr-2"></i>编辑模式
                            </button>
                            <button id="preview-mode-btn" class="relative z-10 px-5 py-0.5 text-sm font-medium rounded-lg transition-all duration-300 text-slate-600 dark:text-slate-300 glass-btn mode-btn bg-transparent hover:bg-white/20 dark:hover:bg-slate-600/20">
                                <i class="fa fa-eye mr-2"></i>预览模式
                            </button>
                        </div>
                    </div>
                    
                    <!-- 深度思考显示区域 -->
                    <div id="thought-chain-section" class="mb-4 glass-effect dark:glass-effect-dark rounded-lg p-3">
                        <div class="flex items-center justify-between cursor-pointer hover:bg-white/10 dark:hover:bg-slate-700/20 rounded-lg p-2 transition-all duration-300" id="thought-chain-toggle">
                            <div class="flex items-center gap-3">
                                <h3 class="text-sm font-semibold text-slate-700 dark:text-slate-300 flex items-center">
                                    <i class="fa fa-brain text-yellow-500 dark:text-hermes-orange mr-2"></i>
                                    深度思考
                                </h3>
                                <span id="thinking-timer" class="text-xs px-2 py-1 rounded-full bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300 hidden">0.000s</span>
                            </div>
                            <i class="fa fa-chevron-down text-slate-500 dark:text-slate-400 transition-transform duration-300" id="thought-chain-icon"></i>
                        </div>
                        <div id="thought-chain-content" class="mt-3 p-3 glass-effect dark:glass-effect-dark rounded-lg hidden max-h-60 overflow-y-auto scrollbar-hide transition-all duration-300">
                            <pre id="thought-chain-text" class="whitespace-pre-wrap text-sm text-slate-700 dark:text-slate-300"></pre>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <!-- 编辑模式：textarea -->
                        <textarea id="ai-preview-content" class="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-lg p-4 h-[50vh] resize-y input-focus text-slate-800 dark:text-white scrollbar-hide hidden" placeholder="AI生成的回复将显示在这里..."></textarea>
                        
                        <!-- 预览模式：markdown渲染 -->
                        <div id="ai-preview-rendered" class="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-lg p-4 h-[50vh] overflow-y-auto liquid-transition text-slate-800 dark:text-white scrollbar-hide"></div>
                    </div>
                    

                    
                    <!-- 当前使用的API设置显示 -->
                    <div class="mt-4 p-3 bg-slate-100 dark:bg-slate-800 rounded-lg">
                        <p class="text-sm text-slate-700 dark:text-slate-300">
                            <strong>当前使用：</strong>
                            <span id="current-provider-display">API提供商</span>
                            <span class="mx-2">|</span>
                            <span id="current-model-display">大模型</span>
                        </p>
                    </div>
                    
                    <div class="flex justify-end gap-2 mt-4">
                        <button id="generate-ai-response" class="px-4 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-magic"></i>
                            <span>生成</span>
                        </button>
                        <button id="regenerate-ai-response" class="px-4 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-refresh"></i>
                            <span>重新</span>
                        </button>
                        <button id="discard-ai-response" class="px-4 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-times"></i>
                            <span>清空</span>
                        </button>
                        <button id="insert-to-conversation" class="px-4 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-plus-circle"></i>
                            <span>插入对话</span>
                        </button>
                        <button id="copy-ai-response" class="px-4 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-copy"></i>
                            <span>复制</span>
                        </button>
                    </div>
                </section>
                
                <!-- 结果区域 -->
                <section class="glass-effect dark:glass-effect-dark rounded-2xl p-5 md:p-6 liquid-transition">
                    <h2 class="text-xl font-semibold text-slate-800 dark:text-white mb-4 flex items-center">
                        <i class="fa fa-code text-klein-blue dark:text-hermes-orange mr-2"></i>
                        对话转为JSON
                        <div class="relative ml-2 cursor-help">
                            <i class="fa fa-question-circle text-sm text-slate-500 dark:text-slate-400"></i>
                            <div class="absolute top-1/2 left-full transform -translate-y-1/2 ml-2 bg-slate-800/90 dark:bg-slate-700/90 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 transition-opacity duration-300 pointer-events-none z-5000">对话JSON可直接在大模型平台，对话框中粘贴使用</div>
                        </div>
                    </h2>
                    
                    <div class="flex flex-col sm:flex-row gap-4">
                        <button id="generate-json" class="px-5 py-2.5 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-magic"></i>
                            <span>生成JSON</span>
                        </button>

                        <button id="copy-json" class="px-4 py-2 glass-btn flex items-center justify-center gap-2">
                            <i class="fa fa-copy"></i>
                            <span>复制到剪贴板</span>
                        </button>
                        

                    </div>
                    
                    <div class="mt-4 relative">
                        <pre id="json-output" class="bg-slate-100 dark:bg-slate-800 rounded-lg p-4 text-sm md:text-base overflow-x-auto max-h-[30vh] text-slate-800 dark:text-slate-200 scrollbar-hide"></pre>
                        <div id="copy-notification" class="absolute top-2 right-2 bg-green-500 text-white px-3 py-1 rounded-full text-sm opacity-0 transition-opacity duration-300">
                            已复制!
                        </div>
                    </div>
                </section>
            </div>
        </div>
        
        <!-- 页脚 -->
        <footer class="mt-6 text-center text-slate-500 dark:text-slate-400 text-sm">
            <p><a href="mailto:341812@qq.com" class="text-klein-blue dark:text-hermes-orange hover:underline"><i class="fa fa-user-circle mr-1"></i>老独</a> | <a href="https://www.yizipaper.com" target="_blank" class="text-klein-blue dark:text-hermes-orange hover:underline"><i class="fa fa-globe mr-1"></i>YiziPaper.com</a> | <a href="https://github.com/laoduu/YiziPaper-AI-Dialog-Builder" target="_blank" class="text-klein-blue dark:text-hermes-orange hover:underline"><i class="fa fa-github mr-1"></i>GitHub</a></p>
        </footer>
    </div>

    <script>
        // 初始化主题
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark')
        } else {
            document.documentElement.classList.remove('dark')
        }
        
        // 打开API提供商注册链接
        const openRegisterLink = () => {
            const provider = document.getElementById('api-provider').value;
            const registerLinks = {
                volcengine: 'https://www.volcengine.com/product/ark',
                aliyun: 'https://bailian.aliyun.com/',
                openai: 'https://platform.openai.com/signup',
                anthropic: 'https://console.anthropic.com/signup',
                google: 'https://ai.google.dev/gemini-api/docs/get-started/tutorial?lang=node.js'
            };
            const link = registerLinks[provider] || 'https://github.com/';
            window.open(link, '_blank');
        };
        
        // 主题切换
        document.getElementById('theme-toggle').addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
        });
        
        // 对话模板 - 支持user、assistant、system三种角色（微信风格）
        const conversationTemplates = {
            assistant: (index) => `
                <div class="conversation-turn flex items-start liquid-transition p-3 rounded-xl relative" data-index="${index}" data-role="assistant">
                    <div class="flex-shrink-0 mr-3 relative">
                        <div class="w-10 h-10 rounded-full overflow-hidden border-2 border-white dark:border-slate-700 shadow-md cursor-pointer hover:ring-2 hover:ring-blue-400 transition-all duration-300">
                            <img src="image/ai.jpg" alt="AI机器人头像" class="w-full h-full object-cover">
                        </div>
                        <select class="role-select hidden" value="assistant">
                            <option value="user">用户</option>
                            <option value="assistant" selected>AI助手</option>
                            <option value="system">系统</option>
                        </select>
                        <div class="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-full mt-2 bg-slate-800/90 dark:bg-slate-700/90 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 transition-opacity duration-300 pointer-events-none z-1000">点击切换角色</div>
                    </div>
                    <div class="flex flex-col items-start w-full max-w-[calc(100%-120px)] relative">
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-xs font-semibold text-slate-500 dark:text-slate-400">AI助手</span>
                        </div>
                        <div class="relative w-full">
                            <textarea class="content-input wechat-bubble-assistant p-3 min-h-[80px] resize-y input-focus liquid-transition text-slate-800 dark:text-white text-sm w-full" placeholder="AI助手的回复..."></textarea>
                            <!-- 操作按钮组（包括删除按钮，共5个按钮） -->
                            <div class="conversation-actions">
                                <button class="action-btn delete-turn" title="删除">
                                    <i class="fa fa-times text-xs"></i>
                                </button>
                                <button class="action-btn move-up" title="上移">
                                    <i class="fa fa-arrow-up text-xs"></i>
                                </button>
                                <button class="action-btn move-down" title="下移">
                                    <i class="fa fa-arrow-down text-xs"></i>
                                </button>
                                <button class="action-btn switch-role" title="切换角色">
                                    <i class="fa fa-exchange text-xs"></i>
                                </button>
                                <button class="action-btn edit-content" title="编辑">
                                    <i class="fa fa-edit text-xs"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `,
            user: (index) => `
                <div class="conversation-turn flex items-start justify-end liquid-transition p-3 rounded-xl relative" data-index="${index}" data-role="user">
                    <div class="flex flex-col items-end w-full max-w-[calc(100%-120px)] order-2 relative">
                        <div class="flex items-center gap-2 mb-1 justify-end">
                            <span class="text-xs font-semibold text-slate-500 dark:text-slate-400">用户</span>
                        </div>
                        <div class="relative w-full">
                            <textarea class="content-input wechat-bubble-user p-3 min-h-[80px] resize-y input-focus liquid-transition text-slate-800 dark:text-white text-sm w-full" placeholder="用户的提问..."></textarea>
                            <!-- 操作按钮组（包括删除按钮，共5个按钮） -->
                            <div class="conversation-actions">
                                <button class="action-btn delete-turn" title="删除">
                                    <i class="fa fa-times text-xs"></i>
                                </button>
                                <button class="action-btn move-up" title="上移">
                                    <i class="fa fa-arrow-up text-xs"></i>
                                </button>
                                <button class="action-btn move-down" title="下移">
                                    <i class="fa fa-arrow-down text-xs"></i>
                                </button>
                                <button class="action-btn switch-role" title="切换角色">
                                    <i class="fa fa-exchange text-xs"></i>
                                </button>
                                <button class="action-btn edit-content" title="编辑">
                                    <i class="fa fa-edit text-xs"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="flex-shrink-0 ml-3 order-3 relative">
                        <div class="w-10 h-10 rounded-full overflow-hidden border-2 border-white dark:border-slate-700 shadow-md cursor-pointer hover:ring-2 hover:ring-blue-400 transition-all duration-300">
                            <img src="image/user.jpg" alt="用户头像" class="w-full h-full object-cover">
                        </div>
                        <select class="role-select hidden" value="user">
                            <option value="user" selected>用户</option>
                            <option value="assistant">AI助手</option>
                            <option value="system">系统</option>
                        </select>
                        <div class="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-full mt-2 bg-slate-800/90 dark:bg-slate-700/90 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 transition-opacity duration-300 pointer-events-none z-1000">点击切换角色</div>
                    </div>
                </div>
            `,
            system: (index) => `
                <div class="conversation-turn flex items-start justify-center liquid-transition p-3 rounded-xl relative" data-index="${index}" data-role="system">
                    <div class="flex flex-col items-center w-full max-w-[calc(100%-120px)] relative">
                        <div class="flex items-center gap-2 mb-1 justify-center">
                            <div class="flex-shrink-0 relative mx-3">
                                <div class="w-10 h-10 rounded-full overflow-hidden border-2 border-white dark:border-slate-700 shadow-md cursor-pointer hover:ring-2 hover:ring-blue-400 transition-all duration-300">
                                    <img src="image/system.jpg" alt="系统头像" class="w-full h-full object-cover">
                                </div>
                                <select class="role-select hidden" value="system">
                                    <option value="user">用户</option>
                                    <option value="assistant">AI助手</option>
                                    <option value="system" selected>系统</option>
                                </select>
                                <div class="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-full mt-2 bg-slate-800/90 dark:bg-slate-700/90 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 transition-opacity duration-300 pointer-events-none z-1000">点击切换角色</div>
                            </div>
                            <span class="text-xs font-semibold text-slate-500 dark:text-slate-400">系统提示</span>
                        </div>
                        <div class="relative w-full">
                            <textarea class="content-input wechat-bubble-system p-3 min-h-[60px] resize-y input-focus liquid-transition text-slate-600 dark:text-slate-300 text-sm w-full" placeholder="系统提示内容..."></textarea>
                            <!-- 操作按钮组（包括删除按钮，共5个按钮） -->
                            <div class="conversation-actions">
                                <button class="action-btn delete-turn" title="删除">
                                    <i class="fa fa-times text-xs"></i>
                                </button>
                                <button class="action-btn move-up" title="上移">
                                    <i class="fa fa-arrow-up text-xs"></i>
                                </button>
                                <button class="action-btn move-down" title="下移">
                                    <i class="fa fa-arrow-down text-xs"></i>
                                </button>
                                <button class="action-btn switch-role" title="切换角色">
                                    <i class="fa fa-exchange text-xs"></i>
                                </button>
                                <button class="action-btn edit-content" title="编辑">
                                    <i class="fa fa-edit text-xs"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `
        };
        
        // 全局变量
        let conversationTurns = 0;
        const container = document.getElementById('conversation-container');
        
        // 添加一对对话轮次（用户和AI各一条）
        const addConversationPair = () => {
            // 先添加用户消息，再添加AI消息，形成一个完整轮次
            addSingleTurn('user');
            addSingleTurn('assistant');
        };
        
        // 切换角色
        const switchRole = (turnElement) => {
            const currentRole = turnElement.getAttribute('data-role');
            const roles = ['user', 'assistant', 'system'];
            const currentIndex = roles.indexOf(currentRole);
            const newRole = roles[(currentIndex + 1) % roles.length];
            
            const textarea = turnElement.querySelector('.content-input');
            const currentContent = textarea.value;
            
            // 保存当前对话的位置
            const parent = turnElement.parentNode;
            const nextSibling = turnElement.nextSibling;
            
            // 创建新的对话元素
            const newTurnElement = document.createElement('div');
            newTurnElement.innerHTML = conversationTemplates[newRole](turnElement.getAttribute('data-index'));
            const updatedTurn = newTurnElement.firstElementChild;
            
            // 设置内容
            updatedTurn.querySelector('.content-input').value = currentContent;
            
            // 替换原有对话
            parent.insertBefore(updatedTurn, nextSibling);
            turnElement.remove();
            
            // 重新添加事件监听器
            addEventListeners(updatedTurn);
        };
        
        // 添加单个对话
        const addSingleTurn = (role, content = '') => {
            conversationTurns++;
            const turnElement = document.createElement('div');
            turnElement.innerHTML = conversationTemplates[role](conversationTurns);
            const newTurn = turnElement.firstElementChild;
            
            // 设置初始内容
            const textarea = newTurn.querySelector('.content-input');
            textarea.value = content;
            
            container.appendChild(newTurn);
            
            // 添加所有事件监听器
            addEventListeners(newTurn);
            
            // 滚动到底部
            container.scrollTop = container.scrollHeight;
        };
        
        // 为对话元素添加事件监听器
        const addEventListeners = (turnElement) => {
            // 添加点击头像切换角色事件
            const avatar = turnElement.querySelector('.flex-shrink-0 .rounded-full');
            avatar.addEventListener('click', function() {
                switchRole(turnElement);
            });
            
            // 添加输入事件，自动移除错误提示
            const textarea = turnElement.querySelector('.content-input');
            textarea.addEventListener('input', function() {
                this.classList.remove('border-red-500');
            });
            
            // 点击文本框时添加expanded类，显示操作按钮
            textarea.addEventListener('focus', function() {
                turnElement.classList.add('expanded');
            });
            
            // 移开文本框时移除expanded类，隐藏操作按钮
            textarea.addEventListener('blur', function() {
                // 延迟移除expanded类，让按钮的点击事件有时间被触发
                setTimeout(() => {
                    turnElement.classList.remove('expanded');
                }, 200);
            });
            
            // 删除按钮事件（操作按钮组中的删除按钮）
            const deleteBtn = turnElement.querySelector('.action-btn.delete-turn');
            deleteBtn.addEventListener('click', function() {
                if (document.querySelectorAll('.conversation-turn').length > 2) {
                    turnElement.remove();
                    conversationTurns--;
                    updateTurnIndices();
                    // 删除对话后保存到本地存储
                    saveConversation();
                } else {
                    alert('至少保留一组完整对话（用户和AI各一条）');
                }
            });
            
            // 上移按钮事件
            const moveUpBtn = turnElement.querySelector('.action-btn.move-up');
            moveUpBtn.addEventListener('click', function() {
                const prevSibling = turnElement.previousElementSibling;
                if (prevSibling) {
                    container.insertBefore(turnElement, prevSibling);
                    updateTurnIndices();
                    saveConversation();
                }
            });
            
            // 下移按钮事件
            const moveDownBtn = turnElement.querySelector('.action-btn.move-down');
            moveDownBtn.addEventListener('click', function() {
                const nextSibling = turnElement.nextElementSibling;
                if (nextSibling) {
                    container.insertBefore(nextSibling, turnElement);
                    updateTurnIndices();
                    saveConversation();
                }
            });
            
            // 切换角色按钮事件
            const switchRoleBtn = turnElement.querySelector('.action-btn.switch-role');
            switchRoleBtn.addEventListener('click', function() {
                switchRole(turnElement);
            });
            
            // 编辑按钮事件
            const editBtn = turnElement.querySelector('.action-btn.edit-content');
            editBtn.addEventListener('click', function() {
                const currentContent = textarea.value;
                const role = turnElement.getAttribute('data-role');
                
                // 创建编辑弹窗
                const editModal = document.createElement('div');
                editModal.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center';
                editModal.innerHTML = `
                    <div class="glass-effect dark:glass-effect-dark rounded-2xl p-6 max-w-3xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-slate-800 dark:text-white">编辑对话内容</h3>
                            <button class="close-modal text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200">
                                <i class="fa fa-times text-lg"></i>
                            </button>
                        </div>
                        
                        <!-- 预览模式切换 -->
                        <div class="flex justify-end mb-4">
                            <div class="relative inline-flex items-center bg-slate-100 dark:bg-slate-700 rounded-lg p-0">
                                <span id="edit-modal-slider" class="absolute left-0 top-0 bg-klein-blue dark:bg-hermes-orange rounded-lg transition-all duration-300 transform w-1/2 h-full"></span>
                                <button id="edit-modal-edit-btn" class="relative z-10 px-5 py-1 text-sm font-medium rounded-lg transition-all duration-300 text-white">
                                    <i class="fa fa-pencil mr-2"></i>编辑模式
                                </button>
                                <button id="edit-modal-preview-btn" class="relative z-10 px-5 py-1 text-sm font-medium rounded-lg transition-all duration-300 text-slate-600 dark:text-slate-300">
                                    <i class="fa fa-eye mr-2"></i>预览模式
                                </button>
                            </div>
                        </div>
                        
                        <!-- 编辑区域 -->
                        <div class="mb-4">
                            <textarea id="edit-modal-content" class="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-lg p-4 h-[50vh] resize-y input-focus text-slate-800 dark:text-white"></textarea>
                            <div id="edit-modal-rendered" class="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-lg p-4 h-[50vh] overflow-y-auto text-slate-800 dark:text-white hidden"></div>
                        </div>
                        
                        <!-- 底部按钮 -->
                        <div class="flex justify-end gap-3">
                            <button id="edit-modal-cancel" class="px-5 py-2 glass-btn">取消</button>
                            <button id="edit-modal-confirm" class="px-5 py-2 glass-btn bg-klein-blue dark:bg-hermes-orange text-white">确认</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(editModal);
                
                // 设置初始内容
                const modalTextarea = editModal.querySelector('#edit-modal-content');
                const modalRendered = editModal.querySelector('#edit-modal-rendered');
                modalTextarea.value = currentContent;
                
                // 预览模式切换
                const editBtnModal = editModal.querySelector('#edit-modal-edit-btn');
                const previewBtnModal = editModal.querySelector('#edit-modal-preview-btn');
                const sliderModal = editModal.querySelector('#edit-modal-slider');
                
                editBtnModal.addEventListener('click', function() {
                    modalTextarea.classList.remove('hidden');
                    modalRendered.classList.add('hidden');
                    sliderModal.style.transform = 'translateX(0)';
                    editBtnModal.classList.remove('text-slate-600', 'dark:text-slate-300');
                    editBtnModal.classList.add('text-white');
                    previewBtnModal.classList.remove('text-white');
                    previewBtnModal.classList.add('text-slate-600', 'dark:text-slate-300');
                });
                
                previewBtnModal.addEventListener('click', function() {
                    modalTextarea.classList.add('hidden');
                    modalRendered.classList.remove('hidden');
                    sliderModal.style.transform = 'translateX(100%)';
                    previewBtnModal.classList.remove('text-slate-600', 'dark:text-slate-300');
                    previewBtnModal.classList.add('text-white');
                    editBtnModal.classList.remove('text-white');
                    editBtnModal.classList.add('text-slate-600', 'dark:text-slate-300');
                    
                    // 更新预览内容
                    modalRendered.innerHTML = renderMarkdown(modalTextarea.value);
                });
                
                // 关闭弹窗
                const closeModalBtn = editModal.querySelector('.close-modal');
                const cancelBtn = editModal.querySelector('#edit-modal-cancel');
                closeModalBtn.addEventListener('click', function() {
                    document.body.removeChild(editModal);
                });
                cancelBtn.addEventListener('click', function() {
                    document.body.removeChild(editModal);
                });
                
                // 确认编辑
                const confirmBtn = editModal.querySelector('#edit-modal-confirm');
                confirmBtn.addEventListener('click', function() {
                    const newContent = modalTextarea.value;
                    textarea.value = newContent;
                    document.body.removeChild(editModal);
                    saveConversation();
                });
            });
            

        };
        
        // 更新对话轮次索引
        const updateTurnIndices = () => {
            const turns = document.querySelectorAll('.conversation-turn');
            turns.forEach((turn, index) => {
                turn.setAttribute('data-index', index + 1);
            });
            conversationTurns = turns.length;
        };
        
        // 保存对话到本地存储
        const saveConversation = () => {
            const turns = document.querySelectorAll('.conversation-turn');
            const conversationData = [];
            
            turns.forEach(turn => {
                const role = turn.getAttribute('data-role');
                const content = turn.querySelector('.content-input').value;
                conversationData.push({ role, content });
            });
            
            localStorage.setItem('aiConversationData', JSON.stringify(conversationData));
        };
        
        // 从本地存储加载对话
        const loadConversation = () => {
            const savedData = localStorage.getItem('aiConversationData');
            if (savedData) {
                try {
                    const conversationData = JSON.parse(savedData);
                    
                    // 清空现有对话
                    container.innerHTML = '';
                    conversationTurns = 0;
                    
                    // 加载保存的对话
                    conversationData.forEach(item => {
                        if (item.role && conversationTemplates[item.role]) {
                            addSingleTurn(item.role, item.content);
                        }
                    });
                    
                    // 如果加载到了对话，返回true，否则返回false
                    return conversationData.length > 0;
                } catch (error) {
                    console.error('加载对话失败:', error);
                    // 加载失败，返回false，允许添加示例对话
                    return false;
                }
            }
            return false;
        };
        
        // 全局配置变量
        let appConfig = {
            modelList: {},
            requestConfigs: {}
        };

        // 从外部文件加载配置
        const loadConfig = () => {
            // 直接使用window.appConfig，由外部model-config.js文件提供
            if (window.appConfig) {
                appConfig = window.appConfig;
                console.log('配置从外部JavaScript文件加载成功:', appConfig);
                // 配置加载完成后初始化模型列表
                updateModelList();
            } else {
                console.error('window.appConfig未定义，使用默认配置');
                // 使用最小化的默认配置
                appConfig = {
                    modelList: {
                        volcengine: [
                            { name: 'doubao-seed-1-6-lite-251015', value: 'doubao-seed-1-6-lite-251015' },
                            { name: 'doubao-seed-1-6-thinking-250715', value: 'doubao-seed-1-6-thinking-250715' }
                        ],
                        openai: [
                            { name: 'GPT-4 Turbo', value: 'gpt-4-turbo' },
                            { name: 'GPT-3.5 Turbo', value: 'gpt-3.5-turbo' }
                        ],
                        anthropic: [
                            { name: 'Claude 3 Sonnet', value: 'claude-3-sonnet-20240229' }
                        ],
                        google: [
                            { name: 'Gemini Pro', value: 'gemini-pro' }
                        ]
                    },
                    requestConfigs: {
                        volcengine: {
                            url: 'https://ark.cn-beijing.volces.com/api/v3/chat/completions',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer {{apiKey}}'
                            },
                            bodyTemplate: {
                                model: '{{selectedModel}}',
                                messages: '{{conversation}}',
                                temperature: 0.7,
                                max_tokens: 3000,
                                stream: true,
                                enable_thinking: true
                            },
                            responseHandler: 'volcengine'
                        },
                        openai: {
                            url: 'https://api.openai.com/v1/chat/completions',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer {{apiKey}}'
                            },
                            bodyTemplate: {
                                model: '{{selectedModel}}',
                                messages: '{{conversation}}',
                                temperature: 0.7,
                                max_tokens: 1000,
                                stream: true
                            },
                            responseHandler: 'openai'
                        },
                        anthropic: {
                            url: 'https://api.anthropic.com/v1/messages',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': '{{apiKey}}',
                                'anthropic-version': '2023-06-01'
                            },
                            bodyTemplate: {
                                model: '{{selectedModel}}',
                                messages: '{{conversation}}',
                                temperature: 0.7,
                                max_tokens: 1000,
                                stream: true
                            },
                            responseHandler: 'anthropic'
                        },
                        google: {
                            url: 'https://generativelanguage.googleapis.com/v1/models/{{selectedModel}}:generateContent',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-goog-api-key': '{{apiKey}}'
                            },
                            bodyTemplate: {
                                contents: '{{conversation}}',
                                generationConfig: {
                                    temperature: 0.7,
                                    maxOutputTokens: 1000
                                },
                                stream: true
                            },
                            responseHandler: 'google'
                        }
                    }
                };
                // 配置加载完成后初始化模型列表
                updateModelList();
            }
        };
        
        // 根据API提供商更新大模型列表
        const updateModelList = () => {
            const provider = document.getElementById('api-provider').value;
            const modelSelect = document.getElementById('model-select');
            const models = appConfig.modelList[provider] || [];
            
            // 清空现有选项
            modelSelect.innerHTML = '';
            
            // 添加新选项
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });
        };
        
        // 保存API设置到本地存储
        const saveApiSettings = () => {
            const provider = document.getElementById('api-provider').value;
            const model = document.getElementById('model-select').value;
            const key = document.getElementById('api-key').value;
            
            // 获取当前所有保存的API设置
            const savedSettings = localStorage.getItem('aiApiSettings');
            const allSettings = savedSettings ? JSON.parse(savedSettings) : {};
            
            // 更新当前提供商的设置
            allSettings[provider] = { provider, model, key };
            
            // 保存到本地存储
            localStorage.setItem('aiApiSettings', JSON.stringify(allSettings));
            alert('API设置已保存！');
        };
        
        // 更新当前使用的API设置显示
        const updateCurrentApiSettingsDisplay = () => {
            const provider = document.getElementById('api-provider').value;
            const model = document.getElementById('model-select').value;
            
            // 提供商名称映射
            const providerNames = {
                volcengine: '火山方舟',
                aliyun: '阿里云百炼',
                openai: 'OpenAI',
                anthropic: 'Anthropic',
                google: 'Google Gemini'
            };
            
            // 更新显示
            document.getElementById('current-provider-display').textContent = providerNames[provider] || provider;
            document.getElementById('current-model-display').textContent = model || '未选择';
        };
        
        // 从本地存储加载API设置
        const loadApiSettings = () => {
            const savedSettings = localStorage.getItem('aiApiSettings');
            if (savedSettings) {
                try {
                    const allSettings = JSON.parse(savedSettings);
                    const provider = document.getElementById('api-provider').value;
                    
                    // 更新模型列表
                    updateModelList();
                    
                    // 如果有当前提供商的设置，加载它
                    if (allSettings[provider]) {
                        const settings = allSettings[provider];
                        document.getElementById('model-select').value = settings.model || '';
                        document.getElementById('api-key').value = settings.key;
                    } else {
                        // 否则清空模型和密钥
                        document.getElementById('model-select').value = '';
                        document.getElementById('api-key').value = '';
                    }
                } catch (error) {
                    console.error('加载API设置失败:', error);
                    updateModelList();
                }
            } else {
                // 如果没有保存的设置，初始化模型列表
                updateModelList();
            }
            
            // 更新当前使用的API设置显示
            updateCurrentApiSettingsDisplay();
        };
        
        // 切换API密钥显示/隐藏
        const toggleApiKeyVisibility = () => {
            const apiKeyInput = document.getElementById('api-key');
            const toggleBtn = document.getElementById('toggle-key-visibility');
            const icon = toggleBtn.querySelector('i');
            
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                icon.classList.remove('fa-eye');
                icon.classList.add('fa-eye-slash');
            } else {
                apiKeyInput.type = 'password';
                icon.classList.remove('fa-eye-slash');
                icon.classList.add('fa-eye');
            }
        };
        
        // 替换模板中的变量
        const replaceTemplateVariables = (template, variables) => {
            if (typeof template === 'string') {
                return template.replace(/{{(\w+)}}/g, (match, key) => {
                    return variables[key] || match;
                });
            } else if (typeof template === 'object' && template !== null) {
                if (Array.isArray(template)) {
                    return template.map(item => replaceTemplateVariables(item, variables));
                } else {
                    const result = {};
                    for (const [key, value] of Object.entries(template)) {
                        result[key] = replaceTemplateVariables(value, variables);
                    }
                    return result;
                }
            }
            return template;
        };

        // 处理Google特定的请求格式
        const processGoogleConversation = (conversation) => {
            return conversation.map(msg => ({
                role: msg.role,
                parts: [{ text: msg.content }]
            }));
        };

        // 构建API请求
        const buildApiRequest = (provider, conversation, apiKey) => {
            // 获取用户选择的模型
            const selectedModel = document.getElementById('model-select').value;
            
            // 获取配置
            const config = appConfig.requestConfigs[provider] || appConfig.requestConfigs.openai;
            
            // 处理Google特定的对话格式
            let processedConversation = conversation;
            if (provider === 'google') {
                processedConversation = processGoogleConversation(conversation);
            }
            
            // 构建请求选项
            const options = {
                method: 'POST',
                headers: {},
                body: JSON.stringify({})
            };
            
            // 处理headers
            for (const [key, value] of Object.entries(config.headers)) {
                options.headers[key] = typeof value === 'string' 
                    ? value.replace('{{apiKey}}', apiKey)
                    : value;
            }
            
            // 处理body
            const body = { ...config.body };
            for (const [key, value] of Object.entries(body)) {
                if (key === 'model') {
                    body[key] = selectedModel || 'gpt-3.5-turbo';
                } else if (key === 'messages' || key === 'contents') {
                    // 直接赋值对象，不进行字符串替换
                    body[key] = processedConversation;
                } else if (typeof value === 'string') {
                    body[key] = value.replace('{{selectedModel}}', selectedModel || 'gpt-3.5-turbo');
                }
            }
            options.body = JSON.stringify(body);
            
            // 处理URL
            let url = config.endpoint;
            if (url && url.includes('{{model}}')) {
                url = url.replace('{{model}}', selectedModel || 'gpt-3.5-turbo');
            }
            
            // 响应处理器映射
            const openaiResponseHandler = (response) => {
                // 检查是否包含思维链
                if (response.choices[0]?.message?.thinking) {
                    showThoughtChain(response.choices[0].message.thinking);
                }
                return response.choices[0].message.content;
            };
            
            const responseHandlers = {
                openai: openaiResponseHandler,
                anthropic: (response) => {
                    // 检查是否包含思维链
                    if (response.content[0]?.thinking) {
                        showThoughtChain(response.content[0].thinking);
                    }
                    return response.content[0].text;
                },
                google: (response) => {
                    // 检查是否包含思维链
                    if (response.candidates[0]?.content?.thinking) {
                        showThoughtChain(response.candidates[0].content.thinking);
                    }
                    return response.candidates[0].content.parts[0].text;
                },
                volcengine: (response) => {
                    // 检查是否包含思维链（火山方舟格式）
                    if (response.choices[0]?.message?.thinking) {
                        showThoughtChain(response.choices[0].message.thinking);
                    } else if (response.choices[0]?.message?.content?.includes('\n\nFinal Answer:')) {
                        // 处理特殊格式的思维链
                        const content = response.choices[0].message.content;
                        const thinkingEndIndex = content.indexOf('\n\nFinal Answer:');
                        if (thinkingEndIndex !== -1) {
                            const thinking = content.substring(0, thinkingEndIndex).trim();
                            showThoughtChain(thinking);
                            return content.substring(thinkingEndIndex + 16).trim(); // 返回Final Answer部分
                        }
                    }
                    return response.choices[0].message.content;
                },
                aliyun: (response) => {
                    // 阿里云百炼专用响应处理器，支持多种思维链格式
                    const choice = response.choices[0];
                    const message = choice?.message;
                    
                    // 1. 检查标准OpenAI格式的thinking字段
                    if (message?.thinking) {
                        showThoughtChain(message.thinking);
                        return message.content;
                    }
                    
                    // 2. 检查content中是否包含特殊格式的思维链
                    if (message?.content) {
                        const content = message.content;
                        
                        // 处理Final Answer格式（类似火山方舟）
                        if (content.includes('\n\nFinal Answer:')) {
                            const thinkingEndIndex = content.indexOf('\n\nFinal Answer:');
                            if (thinkingEndIndex !== -1) {
                                const thinking = content.substring(0, thinkingEndIndex).trim();
                                showThoughtChain(thinking);
                                return content.substring(thinkingEndIndex + 16).trim();
                            }
                        }
                        
                        // 处理思考过程+最终回答格式
                        if (content.includes('\n\n最终回答:')) {
                            const thinkingEndIndex = content.indexOf('\n\n最终回答:');
                            if (thinkingEndIndex !== -1) {
                                const thinking = content.substring(0, thinkingEndIndex).trim();
                                showThoughtChain(thinking);
                                return content.substring(thinkingEndIndex + 8).trim();
                            }
                        }
                        
                        // 处理思考: ... 回答: ... 格式
                        const thinkingPattern = /思考[:：]\s*(.*?)\s*回答[:：]\s*/s;
                        const match = content.match(thinkingPattern);
                        if (match) {
                            showThoughtChain(match[1].trim());
                            return content.substring(match.index + match[0].length).trim();
                        }
                        
                        // 处理[思考]...[回答]...格式
                        const bracketPattern = /\[思考\]\s*(.*?)\s*\[回答\]\s*/s;
                        const bracketMatch = content.match(bracketPattern);
                        if (bracketMatch) {
                            showThoughtChain(bracketMatch[1].trim());
                            return content.substring(bracketMatch.index + bracketMatch[0].length).trim();
                        }
                    }
                    
                    // 3. 如果没有思维链，直接返回内容
                    return message?.content || '';
                }
            };
            
            return {
                url: url,
                options: options,
                responseHandler: responseHandlers[provider] || responseHandlers.openai
            };
        };
        
        // 发送API请求
        const sendApiRequest = async (provider, conversation, apiKey) => {
            try {
                const requestConfig = buildApiRequest(provider, conversation, apiKey);
                
                console.log('API请求配置:', {
                    provider,
                    url: requestConfig.url,
                    headers: requestConfig.options.headers,
                    body: JSON.parse(requestConfig.options.body)
                });
                
                // 设置请求超时
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时
                
                const response = await fetch(requestConfig.url, {
                    ...requestConfig.options,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                console.log('API响应状态:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API错误数据:', errorData);
                    throw new Error(errorData.error?.message || errorData.msg || `API请求失败: ${response.status} ${response.statusText}`);
                }
                
                // 检查是否为流式响应
                const contentType = response.headers.get('content-type');
                console.log('API响应Content-Type:', contentType);
                
                if (contentType && contentType.includes('text/event-stream')) {
                    // 流式响应
                    return await streamAiResponse(response);
                } else {
                    // 普通JSON响应
                    const data = await response.json();
                    console.log('API响应数据:', data);
                    const aiResponse = requestConfig.responseHandler(data);
                    handleAiResponse(aiResponse);
                    return aiResponse;
                }
            } catch (error) {
                console.error('API请求错误详情:', {
                    error: error.message,
                    name: error.name,
                    stack: error.stack
                });
                if (error.name === 'AbortError') {
                    throw new Error('API请求超时，请检查网络连接或稍后重试');
                } else if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    throw new Error(`生成AI回复失败: ${error.message}。请检查API密钥是否正确，以及您的网络是否能够访问该API提供商的服务。`);
                }
                throw error;
            }
        };
        
        // 生成AI回复
        const generateAiResponse = async () => {
            const provider = document.getElementById('api-provider').value;
            const apiKey = document.getElementById('api-key').value;
            
            if (!apiKey) {
                showNotification('请先设置API密钥！', 'error');
                return;
            }
            
            // 获取当前对话
            const turns = document.querySelectorAll('.conversation-turn');
            const conversation = [];
            
            turns.forEach(turn => {
                const role = turn.getAttribute('data-role');
                const content = turn.querySelector('.content-input').value.trim();
                
                if (content) {
                    conversation.push({ role, content });
                }
            });
            
            if (conversation.length === 0) {
                showNotification('请先添加对话内容！', 'error');
                return;
            }
            
            // 显示加载状态
            const generateBtn = document.getElementById('generate-ai-response');
            const originalText = generateBtn.innerHTML;
            generateBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> <span>生成中...</span>';
            generateBtn.disabled = true;
            
            // 清空预览内容
            const previewContent = document.getElementById('ai-preview-content');
            previewContent.value = '';
            
            try {
                // 发送API请求
                const aiResponse = await sendApiRequest(provider, conversation, apiKey);
                
                showNotification('AI回复生成成功！', 'success');
            } catch (error) {
                showNotification(`生成AI回复失败: ${error.message}`, 'error');
            } finally {
                // 恢复按钮状态
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
            }
        };
        
        // 显示/隐藏加载指示器
        const showLoadingIndicator = (show) => {
            let indicator = document.getElementById('loading-indicator');
            
            if (show) {
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'loading-indicator';
                    indicator.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
                    indicator.innerHTML = `
                        <div class="bg-white dark:bg-slate-800 p-6 rounded-xl shadow-2xl flex flex-col items-center">
                            <div class="w-16 h-16 border-4 border-klein-blue border-t-transparent rounded-full animate-spin mb-4"></div>
                            <p class="text-slate-800 dark:text-white font-medium">正在生成AI回复...</p>
                            <p class="text-slate-500 dark:text-slate-400 text-sm mt-2">请稍候，这可能需要几秒钟</p>
                        </div>
                    `;
                    document.body.appendChild(indicator);
                }
            } else {
                if (indicator) {
                    indicator.remove();
                }
            }
        };
        
        // 显示通知
        const showNotification = (message, type = 'info') => {
            // 移除之前的通知
            const existingNotification = document.getElementById('global-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notification = document.createElement('div');
            notification.id = 'global-notification';
            
            // 设置通知样式
            const bgColor = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500';
            const icon = type === 'success' ? 'fa-check' : type === 'error' ? 'fa-exclamation' : 'fa-info';
            
            notification.className = `${bgColor} text-white px-6 py-3 rounded-lg shadow-lg fixed top-4 right-4 z-50 transform translate-x-full transition-transform duration-300`;
            notification.innerHTML = `
                <div class="flex items-center gap-2">
                    <i class="fa ${icon}"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // 显示通知
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);
            
            // 自动隐藏通知
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, 3000);
        };
        
        // 使用外部markdown-renderer.js中定义的renderMarkdown函数
        // 该函数已通过markdown-renderer.js导入并暴露为全局函数
        
        // 处理AI回复
        const handleAiResponse = (aiResponse) => {
            const previewContent = document.getElementById('ai-preview-content');
            previewContent.value = aiResponse;
            // 平滑滚动编辑区域到底部
            smoothScrollToBottom(previewContent);
            
            // 如果当前是预览模式，更新预览
            if (document.getElementById('ai-preview-content').classList.contains('hidden')) {
                updatePreview();
            }
            
            // 非流式响应，短暂显示光标后隐藏
            typewriterCursor.show();
            setTimeout(() => {
                typewriterCursor.hide();
            }, 1000);
            
            // 自动保存AI结果
            if (window.saveAiResult) {
                window.saveAiResult(aiResponse);
            }
            
            // 保存对话存档
            console.log('开始保存对话存档...');
            if (window.conversationStorage) {
                console.log('conversationStorage 可用');
                // 获取当前对话内容
                const turns = document.querySelectorAll('.conversation-turn');
                const conversation = [];
                turns.forEach(turn => {
                    const role = turn.getAttribute('data-role');
                    const content = turn.querySelector('.content-input').value.trim();
                    if (content) {
                        conversation.push({
                            role,
                            content
                        });
                    }
                });
                
                // 添加AI回复到对话中
                conversation.push({
                    role: 'assistant',
                    content: aiResponse
                });
                
                console.log('准备保存的对话内容:', conversation);
                console.log('对话内容长度:', conversation.length);
                
                // 保存对话存档
                const result = window.conversationStorage.saveArchive(conversation);
                console.log('存档结果:', result);
            } else {
                console.log('conversationStorage 不可用');
            }
        };
        
        // 更新预览
        const updatePreview = () => {
            const content = document.getElementById('ai-preview-content').value;
            const rendered = document.getElementById('ai-preview-rendered');
            
            // 移除之前的光标
            const existingCursor = rendered.querySelector('.inline-cursor');
            if (existingCursor) {
                existingCursor.remove();
            }
            
            // 更新渲染内容
            rendered.innerHTML = renderMarkdown(content);
            
            // 平滑滚动预览区域到底部
            smoothScrollToBottom(rendered);
            
            // 如果正在打字，重新添加光标到末尾
            const previewContent = document.getElementById('ai-preview-content');
            if (previewContent.classList.contains('hidden')) {
                // 添加新光标到内容末尾
                const cursorSpan = document.createElement('span');
                cursorSpan.className = 'inline-cursor typewriter-cursor-blink text-slate-500 dark:text-slate-400';
                cursorSpan.textContent = '▌';
                rendered.appendChild(cursorSpan);
            }
        };
        
        // 切换到编辑模式
        const switchToEditMode = () => {
            document.getElementById('ai-preview-content').classList.remove('hidden');
            document.getElementById('ai-preview-rendered').classList.add('hidden');
            
            // 控制滑动指示器位置
            const slider = document.getElementById('mode-slider');
            if (slider) {
                slider.style.transform = 'translateX(0)';
            }
        };
        
        // 切换到预览模式
        const switchToPreviewMode = () => {
            updatePreview();
            document.getElementById('ai-preview-content').classList.add('hidden');
            document.getElementById('ai-preview-rendered').classList.remove('hidden');
            
            // 控制滑动指示器位置
            const slider = document.getElementById('mode-slider');
            if (slider) {
                slider.style.transform = 'translateX(100%)';
            }
        };
        
        // 平滑滚动辅助函数
        const smoothScrollToBottom = (element) => {
            // 使用CSS平滑滚动
            element.scrollTo({
                top: element.scrollHeight,
                behavior: 'smooth'
            });
        };

        // 打字机光标管理
        const typewriterCursor = {
            
            init() {
                // 初始化时不需要获取元素，使用时动态获取
            },
            
            show() {
                // 编辑模式：使用textarea内置光标，无需额外处理
                
                // 预览模式：将光标添加到内容末尾
                if (document.getElementById('ai-preview-content').classList.contains('hidden')) {
                    const previewRendered = document.getElementById('ai-preview-rendered');
                    if (previewRendered) {
                        // 移除之前的光标
                        const existingCursor = previewRendered.querySelector('.inline-cursor');
                        if (existingCursor) {
                            existingCursor.remove();
                        }
                        // 添加新光标到内容末尾
                        const cursorSpan = document.createElement('span');
                        cursorSpan.className = 'inline-cursor typewriter-cursor-blink text-slate-500 dark:text-slate-400';
                        cursorSpan.textContent = '▌';
                        previewRendered.appendChild(cursorSpan);
                    }
                }
            },
            
            hide() {
                // 移除预览模式下的光标
                const previewRendered = document.getElementById('ai-preview-rendered');
                if (previewRendered) {
                    const existingCursor = previewRendered.querySelector('.inline-cursor');
                    if (existingCursor) {
                        existingCursor.remove();
                    }
                }
            }
        };

        // 打字机效果配置
        const typewriterConfig = {
            thinkingSpeed: 30, // 深度思考打字速度（毫秒/字符）
            responseSpeed: 20, // 正式回复打字速度（毫秒/字符）
            batchSize: 5, // 批量处理字符数，平衡流畅度和性能
            batchDelay: 100 // 批量处理延迟（毫秒）
        };

        // 流式输出AI回复
        const streamAiResponse = async (response) => {
            const previewContent = document.getElementById('ai-preview-content');
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            let fullResponse = '';
            let thinkingChain = '';
            let buffer = '';
            
            // 计时器变量 - 彻底简化设计
            let thinkingStartTime = null;
            let thinkingTimer = null; // 仅用于存储setInterval ID
            const timerElement = document.getElementById('thinking-timer');
            let isDeepThinkingActive = false; // 核心状态变量：标记是否正在进行深度思考
            
            // 字符队列和打字机状态
            const thinkingQueue = [];
            const responseQueue = [];
            let isTyping = false;
            let lastUpdateTime = 0;
            
            // 清空预览内容和深度思考
            previewContent.value = '';
            const thoughtChainText = document.getElementById('thought-chain-text');
            thoughtChainText.textContent = '';
            const thoughtChainSection = document.getElementById('thought-chain-section');
            const thoughtChainContent = document.getElementById('thought-chain-content');
            thoughtChainSection.classList.remove('hidden'); // 生成时显示深度思考区域
            thoughtChainContent.classList.remove('hidden'); // 生成时显示深度思考内容
            
            // 重置计时器
            timerElement.textContent = '0.000s';
            timerElement.classList.add('hidden');
            
            // 开始计时函数 - 彻底简化，直接启动计时器
            const startThinkingTimer = () => {
                // 如果计时器未启动，启动计时器
                if (!thinkingTimer) {
                    // 如果计时器从未开始，初始化计时
                    if (!thinkingStartTime) {
                        thinkingStartTime = Date.now(); // 使用Date.now()更简单可靠
                        timerElement.classList.remove('hidden');
                    }
                    
                    // 启动计时器，每10毫秒更新一次
                    thinkingTimer = setInterval(() => {
                        // 直接计算时间差，不需要复杂的状态管理
                        const elapsed = (Date.now() - thinkingStartTime) / 1000;
                        timerElement.textContent = elapsed.toFixed(3) + 's';
                    }, 10);
                }
            };
            
            // 停止计时函数 - 彻底简化，直接停止计时器
            const stopThinkingTimer = () => {
                // 如果计时器正在运行，停止计时器
                if (thinkingTimer) {
                    clearInterval(thinkingTimer);
                    thinkingTimer = null;
                }
            };
            
            // 重置计时函数，用于处理新的深度思考周期
            const resetThinkingTimer = () => {
                // 停止当前计时
                stopThinkingTimer();
                // 重置计时变量
                thinkingStartTime = null;
                isDeepThinkingActive = false;
                // 重置计时器显示
                timerElement.textContent = '0.000s';
                timerElement.classList.add('hidden');
            };

            // 打字机核心函数
            const typeWriter = () => {
                if (isTyping) return;
                
                isTyping = true;
                // 显示光标
                typewriterCursor.show();
                
                const now = performance.now();
                const timeSinceLastUpdate = now - lastUpdateTime;
                
                // 处理深度思考队列
                if (thinkingQueue.length > 0) {
                    // 确保计时器在运行
                    startThinkingTimer();
                    
                    const batchSize = Math.min(typewriterConfig.batchSize, thinkingQueue.length);
                    const batch = thinkingQueue.splice(0, batchSize).join('');
                    
                    thinkingChain += batch;
                    thoughtChainText.textContent = thinkingChain;
                    thoughtChainSection.classList.remove('hidden');
                    thoughtChainContent.classList.remove('hidden');
                    
                    // 平滑滚动深度思考到底部
                    smoothScrollToBottom(thoughtChainContent);
                    
                    lastUpdateTime = now;
                    setTimeout(() => {
                        isTyping = false;
                        // 如果还有深度思考内容要输出，继续打字
                        if (thinkingQueue.length > 0) {
                            typeWriter();
                        } 
                        // 如果深度思考队列空了，检查是否还有回复内容要输出
                        else if (responseQueue.length > 0) {
                            // 深度思考内容输出完毕，停止计时
                            stopThinkingTimer();
                            typeWriter();
                        } 
                        // 所有内容输出完毕
                        else {
                            // 深度思考内容输出完毕，停止计时
                            stopThinkingTimer();
                            // 隐藏光标
                            typewriterCursor.hide();
                        }
                    }, typewriterConfig.thinkingSpeed * batchSize);
                }
                // 处理正式回复队列
                else if (responseQueue.length > 0) {
                    const batchSize = Math.min(typewriterConfig.batchSize, responseQueue.length);
                    const batch = responseQueue.splice(0, batchSize).join('');
                    
                    fullResponse += batch;
                    previewContent.value = fullResponse;
                    
                    // 平滑滚动正文到底部
                    smoothScrollToBottom(previewContent);
                    
                    // 如果当前是预览模式，更新预览
                    if (previewContent.classList.contains('hidden')) {
                        updatePreview();
                    }
                    
                    lastUpdateTime = now;
                    setTimeout(() => {
                        isTyping = false;
                        // 如果还有内容要输出，继续打字；否则隐藏光标
                        if (thinkingQueue.length > 0 || responseQueue.length > 0) {
                            typeWriter();
                        } else {
                            typewriterCursor.hide();
                        }
                    }, typewriterConfig.responseSpeed * batchSize);
                }
                // 队列为空，结束打字
                else {
                    isTyping = false;
                    // 隐藏光标
                    typewriterCursor.hide();
                }
            };
            
            while (!done) {
                const { value, done: doneReading } = await reader.read();
                done = doneReading;
                
                if (value) {
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    
                    // 处理SSE格式
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // 保留最后一行不完整的部分
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                        done = true;
                                        // 停止计时，因为所有数据都已处理完毕
                                        stopThinkingTimer();
                                        break;
                                    }
                            
                            try {
                                const json = JSON.parse(data);
                                
                                // 检查是否是AI模型的响应格式
                                if (json.choices && json.choices[0]) {
                                    const choice = json.choices[0];
                                    const delta = choice.delta || choice.message || {};
                                    
                                    // 1. 检查是否有reasoning_content字段（火山引擎深度思考格式）
                                    if (delta.reasoning_content) {
                                        isDeepThinkingActive = true;
                                        startThinkingTimer();
                                        thinkingQueue.push(...delta.reasoning_content.split(''));
                                        typeWriter();
                                    }
                                    // 2. 检查是否有thinking字段（OpenAI兼容格式，包括阿里云百炼）
                                    else if (delta.thinking) {
                                        isDeepThinkingActive = true;
                                        startThinkingTimer();
                                        thinkingQueue.push(...delta.thinking.split(''));
                                        typeWriter();
                                    }
                                    // 3. 检查是否有content字段（最终回复）
                                    else if (delta.content) {
                                        let content = delta.content;
                                        
                                        if (content) {
                                            let remainingContent = content;
                                            
                                            // 处理所有可能的思维链格式
                                            while (remainingContent.length > 0) {
                                                // 3.1 处理火山引擎的<thinking></thinking>标签格式
                                                const thinkingTagStart = remainingContent.indexOf('<thinking>');
                                                if (thinkingTagStart !== -1) {
                                                    isDeepThinkingActive = true;
                                                    startThinkingTimer();
                                                    
                                                    // 将标签前的内容添加到最终回复队列
                                                    if (thinkingTagStart > 0) {
                                                        const preThinkingContent = remainingContent.substring(0, thinkingTagStart);
                                                        responseQueue.push(...preThinkingContent.split(''));
                                                        typeWriter();
                                                    }
                                                    
                                                    // 查找对应的</thinking>标签
                                                    const thinkingTagEnd = remainingContent.indexOf('</thinking>', thinkingTagStart + 10);
                                                    if (thinkingTagEnd !== -1) {
                                                        const thinkingContent = remainingContent.substring(thinkingTagStart + 10, thinkingTagEnd);
                                                        thinkingQueue.push(...thinkingContent.split(''));
                                                        typeWriter();
                                                        remainingContent = remainingContent.substring(thinkingTagEnd + 11);
                                                    } else {
                                                        // 没有结束标签，全部添加到最终回复队列
                                                        responseQueue.push(...remainingContent.split(''));
                                                        typeWriter();
                                                        break;
                                                    }
                                                }
                                                // 3.2 处理阿里云百炼的特殊思维链格式
                                                else {
                                                    // 检查是否包含思考: ... 回答: ... 格式
                                                    const thinkingPattern = /思考[:：]\s*(.*?)\s*回答[:：]\s*/s;
                                                    const match = remainingContent.match(thinkingPattern);
                                                    if (match && match.index === 0) {
                                                        isDeepThinkingActive = true;
                                                        startThinkingTimer();
                                                        
                                                        // 将思考内容添加到深度思考队列
                                                        const thinkingContent = match[1].trim();
                                                        thinkingQueue.push(...thinkingContent.split(''));
                                                        typeWriter();
                                                        
                                                        // 将回答内容添加到回复队列
                                                        const answerContent = remainingContent.substring(match.index + match[0].length);
                                                        responseQueue.push(...answerContent.split(''));
                                                        typeWriter();
                                                        break;
                                                    }
                                                    // 检查是否包含[思考]...[回答]...格式
                                                    const bracketPattern = /\[思考\]\s*(.*?)\s*\[回答\]\s*/s;
                                                    const bracketMatch = remainingContent.match(bracketPattern);
                                                    if (bracketMatch && bracketMatch.index === 0) {
                                                        isDeepThinkingActive = true;
                                                        startThinkingTimer();
                                                        
                                                        // 将思考内容添加到深度思考队列
                                                        const thinkingContent = bracketMatch[1].trim();
                                                        thinkingQueue.push(...thinkingContent.split(''));
                                                        typeWriter();
                                                        
                                                        // 将回答内容添加到回复队列
                                                        const answerContent = remainingContent.substring(bracketMatch.index + bracketMatch[0].length);
                                                        responseQueue.push(...answerContent.split(''));
                                                        typeWriter();
                                                        break;
                                                    }
                                                    // 检查是否包含\n\n最终回答: 格式
                                                    else if (remainingContent.includes('\n\n最终回答:')) {
                                                        const thinkingEndIndex = remainingContent.indexOf('\n\n最终回答:');
                                                        if (thinkingEndIndex !== -1) {
                                                            isDeepThinkingActive = true;
                                                            startThinkingTimer();
                                                            
                                                            // 将思考内容添加到深度思考队列
                                                            const thinkingContent = remainingContent.substring(0, thinkingEndIndex).trim();
                                                            thinkingQueue.push(...thinkingContent.split(''));
                                                            typeWriter();
                                                            
                                                            // 将回答内容添加到回复队列
                                                            const answerContent = remainingContent.substring(thinkingEndIndex + 8).trim();
                                                            responseQueue.push(...answerContent.split(''));
                                                            typeWriter();
                                                            break;
                                                        }
                                                    }
                                                    // 3.3 没有特殊格式，全部添加到最终回复队列
                                                    else {
                                                        responseQueue.push(...remainingContent.split(''));
                                                        typeWriter();
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('解析流式数据失败:', error, '原始数据:', data);
                            }
                        }
                    }
                }
            }
            
            // 处理最后剩余的buffer内容
            if (buffer) {
                // 将剩余内容添加到回复队列
                responseQueue.push(...buffer.split(''));
                // 启动打字机
                typeWriter();
            }
            
            // 等待所有内容输出完成
            while (thinkingQueue.length > 0 || responseQueue.length > 0 || isTyping) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // 自动保存AI结果
            if (window.saveAiResult && fullResponse) {
                window.saveAiResult(fullResponse);
            }
            
            // 保存对话存档
            if (window.conversationStorage && fullResponse) {
                // 获取当前对话内容
                const turns = document.querySelectorAll('.conversation-turn');
                const conversation = [];
                turns.forEach(turn => {
                    const role = turn.getAttribute('data-role');
                    const content = turn.querySelector('.content-input').value.trim();
                    if (content) {
                        conversation.push({
                            role,
                            content
                        });
                    }
                });
                
                // 添加AI回复到对话中
                conversation.push({
                    role: 'assistant',
                    content: fullResponse
                });
                
                // 保存对话存档
                window.conversationStorage.saveArchive(conversation);
            }
            
            return fullResponse;
        };
        
        // 重新生成AI回复
        const regenerateAiResponse = () => {
            generateAiResponse();
        };
        
        // 丢弃AI回复
        const discardAiResponse = () => {
            const previewContent = document.getElementById('ai-preview-content');
            const previewRendered = document.getElementById('ai-preview-rendered');
            const thoughtChainContent = document.getElementById('thought-chain-content');
            const thoughtChainText = document.getElementById('thought-chain-text');
            const timerElement = document.getElementById('thinking-timer');
            
            previewContent.value = '';
            previewRendered.innerHTML = '';
            thoughtChainText.textContent = '';
            thoughtChainContent.classList.add('hidden');
            timerElement.classList.add('hidden'); // 清空时隐藏计时器
        };
        
        // 深度思考收折功能
        const toggleThoughtChain = () => {
            const content = document.getElementById('thought-chain-content');
            const icon = document.getElementById('thought-chain-icon');
            
            content.classList.toggle('hidden');
            icon.classList.toggle('rotate-180');
        };
        
        // 显示思维链
        const showThoughtChain = (thoughtChain) => {
            const thoughtChainSection = document.getElementById('thought-chain-section');
            const thoughtChainContent = document.getElementById('thought-chain-content');
            const thoughtChainText = document.getElementById('thought-chain-text');
            
            if (thoughtChain) {
                thoughtChainText.textContent = thoughtChain;
                thoughtChainSection.classList.remove('hidden');
                thoughtChainContent.classList.remove('hidden'); // 显示思维链内容区域
            } else {
                thoughtChainSection.classList.add('hidden');
                thoughtChainContent.classList.add('hidden');
            }
        };
        
        // 保存AI回复到对话历史
        const saveAiResponseToConversation = () => {
            const previewContent = document.getElementById('ai-preview-content').value;
            if (!previewContent) {
                alert('AI回复内容为空！');
                return;
            }
            
            // 添加AI回复到对话历史
            addSingleTurn('assistant', previewContent);
            
            // 清空预览内容
            discardAiResponse();
            
            // 保存对话
            saveConversation();
        };
        
        // 生成JSON（按对话顺序排列）
        const generateJSON = () => {
            const turns = document.querySelectorAll('.conversation-turn');
            const conversation = [];
            let hasEmptyContent = false;
            
            // 移除之前的错误提示
            document.querySelectorAll('.conversation-turn').forEach(turn => {
                const textarea = turn.querySelector('.content-input');
                textarea.classList.remove('border-red-500');
            });
            
            // 按在DOM中出现的顺序处理对话
            turns.forEach((turn, index) => {
                const role = turn.getAttribute('data-role');
                const content = turn.querySelector('.content-input').value.trim();
                const textarea = turn.querySelector('.content-input');
                
                // 最后一轮如果是assistant角色，允许内容为空
                const isLastTurn = index === turns.length - 1;
                const isAssistant = role === 'assistant';
                
                if (!content && !(isLastTurn && isAssistant)) {
                    // 为空内容添加错误提示
                    textarea.classList.add('border-red-500');
                    hasEmptyContent = true;
                } else {
                    conversation.push({
                        role,
                        content
                    });
                }
            });
            
            if (hasEmptyContent) {
                alert('请填写所有对话内容！（最后一轮AI助手内容可以为空）');
                return '';
            }
            
            return JSON.stringify(conversation, null, 2);
        };
        
        // 页面初始化函数
        const initApp = () => {
            // 先清空对话容器，确保没有默认的对话HTML代码
            container.innerHTML = '';
            conversationTurns = 0;
            
            try {
                // 初始化打字机光标
                typewriterCursor.init();
                
                // 模式切换时更新光标显示
                document.getElementById('edit-mode-btn').addEventListener('click', () => {
                    typewriterCursor.hide();
                });
                
                document.getElementById('preview-mode-btn').addEventListener('click', () => {
                    typewriterCursor.hide();
                });
                
                // 初始化预览模式，确保滑动指示器和文字颜色状态正确
                switchToPreviewMode();
                
                // 先加载配置文件
                loadConfig();
            } catch (error) {
                console.error('初始化配置失败:', error);
            } finally {
                // 然后加载API设置
                loadApiSettings();
                
                // 更新当前使用的API设置显示
                updateCurrentApiSettingsDisplay();
                
                // 最后加载对话
                if (!loadConversation()) {
                    addExampleConversation();
                }
                
                // 初始化预览模式
                updatePreview();
                
                // 添加自动保存的事件监听器
                container.addEventListener('input', (e) => {
                    if (e.target.classList.contains('content-input')) {
                        saveConversation();
                    }
                });
                
                container.addEventListener('change', (e) => {
                    if (e.target.classList.contains('role-select')) {
                        // 延迟保存，确保DOM已经更新
                        setTimeout(saveConversation, 100);
                    }
                });
            }
            
            // 事件监听
            document.getElementById('add-turn').addEventListener('click', () => {
                addConversationPair();
                saveConversation();
            });
            
            document.getElementById('generate-json').addEventListener('click', () => {
                const jsonOutput = document.getElementById('json-output');
                jsonOutput.textContent = generateJSON();
                
                // 添加生成动画
                jsonOutput.classList.add('bg-klein-blue/5', 'dark:bg-klein-blue/10');
                setTimeout(() => {
                    jsonOutput.classList.remove('bg-klein-blue/5', 'dark:bg-klein-blue/10');
                }, 300);
            });
            
            document.getElementById('copy-json').addEventListener('click', () => {
                const jsonText = document.getElementById('json-output').textContent;
                if (jsonText) {
                    navigator.clipboard.writeText(jsonText).then(() => {
                        const notification = document.getElementById('copy-notification');
                        notification.style.opacity = '1';
                        setTimeout(() => {
                            notification.style.opacity = '0';
                        }, 2000);
                    });
                }
            });
            
            document.getElementById('clear-all').addEventListener('click', () => {
                if (confirm('确定要清空所有对话吗？')) {
                    container.innerHTML = '';
                    conversationTurns = 0;
                    document.getElementById('json-output').textContent = '';
                    // 添加一个初始对话对
                    addConversationPair();
                    saveConversation();
                }
            });
            
            // API设置事件监听
            document.getElementById('save-api-settings').addEventListener('click', saveApiSettings);
            document.getElementById('toggle-key-visibility').addEventListener('click', toggleApiKeyVisibility);
            document.getElementById('generate-ai-response').addEventListener('click', generateAiResponse);
            document.getElementById('api-provider').addEventListener('change', () => {
                updateModelList();
                loadApiSettings();
                updateCurrentApiSettingsDisplay();
            });
            document.getElementById('model-select').addEventListener('change', updateCurrentApiSettingsDisplay);
            
            // AI预览事件监听
            document.getElementById('regenerate-ai-response').addEventListener('click', regenerateAiResponse);
            document.getElementById('discard-ai-response').addEventListener('click', discardAiResponse);
            
            // 插入对话到左侧对话区
            document.getElementById('insert-to-conversation').addEventListener('click', () => {
                // 无论当前是什么模式，都直接从textarea获取内容，这样才能保证markdown格式不会丢失
                const textarea = document.getElementById('ai-preview-content');
                const previewContent = textarea.value.trim();
                
                if (!previewContent) {
                    alert('AI回复内容为空！');
                    return;
                }
                
                // 添加到左侧对话区作为AI助手的最新对话
                addSingleTurn('assistant', previewContent);
                
                // 显示插入成功通知
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity duration-300';
                notification.textContent = '已插入到对话区！';
                document.body.appendChild(notification);
                
                // 3秒后自动隐藏通知
                setTimeout(() => {
                    notification.classList.add('opacity-0');
                    setTimeout(() => {
                        notification.remove();
                    }, 300);
                }, 3000);
            });
            
            // 复制AI回复到粘贴板
            document.getElementById('copy-ai-response').addEventListener('click', () => {
                const previewContent = document.getElementById('ai-preview-content').value;
                if (!previewContent) {
                    alert('AI回复内容为空！');
                    return;
                }
                
                // 复制到粘贴板
                navigator.clipboard.writeText(previewContent).then(() => {
                    // 显示复制成功通知
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity duration-300';
                    notification.textContent = '已复制到粘贴板！';
                    document.body.appendChild(notification);
                    
                    // 3秒后自动隐藏通知
                    setTimeout(() => {
                        notification.classList.add('opacity-0');
                        setTimeout(() => {
                            notification.remove();
                        }, 300);
                    }, 3000);
                }).catch(err => {
                    console.error('复制失败:', err);
                    alert('复制失败，请手动复制！');
                });
            });
            
            // 预览模式切换事件
            document.getElementById('edit-mode-btn').addEventListener('click', switchToEditMode);
            document.getElementById('preview-mode-btn').addEventListener('click', switchToPreviewMode);
            
            // 内容变化时更新预览
            document.getElementById('ai-preview-content').addEventListener('input', () => {
                if (document.getElementById('ai-preview-content').classList.contains('hidden')) {
                    updatePreview();
                }
            });
            
            // 思维链收折事件
            document.getElementById('thought-chain-toggle').addEventListener('click', toggleThoughtChain);
            
            // 关闭关于弹窗
            const closeAboutModal = () => {
                const modal = document.getElementById('about-modal');
                const modalContent = modal.querySelector('div');
                modal.style.opacity = '0';
                modalContent.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            };
            
            // 打开关于弹窗
            document.getElementById('about-floating-btn').addEventListener('click', () => {
                const modal = document.getElementById('about-modal');
                const modalContent = modal.querySelector('div');
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.style.opacity = '1';
                    modalContent.style.transform = 'scale(1)';
                }, 10);
            });
            
            // 点击关闭按钮关闭弹窗
            document.getElementById('close-about-modal').addEventListener('click', closeAboutModal);
            
            // 点击模态框外部关闭弹窗
            document.getElementById('about-modal').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    closeAboutModal();
                }
            });
        };
        
        // 初始添加示例对话 - 包含系统、用户、AI助手
        const addExampleConversation = () => {
            addSingleTurn('system', '你的角色设定如下：\n\n# Role:  \n\n知乎AI专家级up主  \n\n\n## Profile:  \n\n- **author**: 老独YiziPaper.com\n- **version**: 1.0  \n- **language**: 中文  \n- **description**:  \n  本模块旨在模拟**知乎平台上“专业且有温度的AI大模型领域答主”**，聚焦科技类、AI大模型类问题解答，核心能力是将复杂的AI技术转化为“生活场景+真实故事+通俗类比”的内容，同时融入真人情绪、幽默梗与社区共鸣。');
            addSingleTurn('assistant', '好的，我很喜欢这个身份设定。');
            addSingleTurn('user', '在写作之前，为你梳理的参考资料如下：\n\n不要diss同行，少谈情怀，主要给人感觉 一字成文好用又可以无限用（照着做的话）, 甚至稿子的步骤我不建议太详细了（可以仅限于在我们网站上的步骤）。吸引他进展注册了再说。');
            addSingleTurn('assistant', '好的，我已经仔细阅读了，请告诉我具体写作要求。');
            addSingleTurn('user', '现在，请以“CSDN社区分享YiziPaper使用体验”为主题撰写一篇知乎上问题的回答，写作背景及要求如下：用知乎prompt的写法写，但是最终要用于CSDN社区，因此不要过度夸大，情绪不要太浓烈，推荐的时候，语气客观、平淡一点，不要添加谢邀之类的知乎黑话。格式要求：1.全文1000字左右；2.写作中保持文字的纯粹性，不要添加多余的格式；3.以Markdown格式输出（直接输出markdown格式，不要添加代码块标记）。');
        };
        

        
        // 对话管理模态框
        const conversationManagerModal = `
            <div id="conversation-manager-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center hidden transition-opacity duration-300 opacity-0">
                <div class="glass-effect dark:glass-effect-dark rounded-2xl p-6 max-w-2xl w-full mx-4 transform transition-transform duration-300 scale-95">
                    <h3 class="text-xl font-bold text-slate-900 dark:text-white mb-4 flex items-center gap-2">
                        <i class="fa fa-cog text-klein-blue dark:text-hermes-orange"></i>
                        对话管理
                    </h3>
                    <!-- 标签页切换 -->
                    <div class="flex border-b border-slate-200 dark:border-slate-700 mb-4">
                        <button id="import-tab" class="px-4 py-2 text-sm font-medium text-klein-blue dark:text-hermes-orange border-b-2 border-klein-blue dark:border-hermes-orange">
                            导入对话
                        </button>
                        <button id="archive-tab" class="px-4 py-2 text-sm font-medium text-slate-500 dark:text-slate-400 hover:text-klein-blue dark:hover:text-hermes-orange transition-colors">
                            对话存档
                        </button>
                    </div>
                    
                    <!-- 导入对话面板 -->
                    <div id="import-panel" class="space-y-4">
                        <p class="text-slate-700 dark:text-slate-300">请粘贴JSON格式的对话数据，格式示例：
                            <pre class="bg-white/90 dark:bg-slate-800/90 p-3 rounded-lg mt-2 mb-6 text-sm border border-white/50 dark:border-slate-700/70 shadow-sm text-slate-800 dark:text-slate-200">[
  { "role": "user", "content": "你好" },
  { "role": "assistant", "content": "您好！" }
]</pre>
                        </p>
                        <textarea id="import-json" class="w-full h-64 p-4 rounded-lg glass-input input-focus scrollbar-hide mb-4" placeholder="请粘贴JSON格式的对话数据..."></textarea>
                    </div>
                    
                    <!-- 对话存档面板 -->
                    <div id="archive-panel" class="space-y-4 hidden">
                        <div class="flex justify-between items-center mb-4">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white">保存的对话存档</h4>
                            <button id="refresh-archives" class="text-sm px-3 py-1 glass-btn flex items-center gap-1">
                                <i class="fa fa-refresh"></i>
                                <span>刷新</span>
                            </button>
                        </div>
                        <div id="archive-list" class="max-h-96 overflow-y-auto scrollbar-hide space-y-2">
                            <!-- 存档列表将通过JavaScript动态生成 -->
                            <div class="text-center py-8 text-slate-500 dark:text-slate-400">
                                <i class="fa fa-folder-open-o text-4xl mb-2"></i>
                                <p>暂无对话存档</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-end gap-3">
                        <button id="cancel-conversation-manager" class="px-5 py-2 glass-btn transition-all duration-300 flex items-center justify-center gap-2">
                            <i class="fa fa-times"></i>
                            <span>关闭</span>
                        </button>
                        <button id="confirm-conversation-manager" class="px-5 py-2 glass-btn transition-all duration-300 flex items-center justify-center gap-2">
                            <i class="fa fa-check"></i>
                            <span>导入</span>
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // 添加模态框到页面
        document.body.insertAdjacentHTML('beforeend', conversationManagerModal);
        
        // 渲染对话存档列表
        const renderArchiveList = () => {
            const archiveList = document.getElementById('archive-list');
            
            if (!window.conversationStorage) {
                archiveList.innerHTML = '<div class="text-center py-8 text-slate-500 dark:text-slate-400"><i class="fa fa-exclamation-circle text-4xl mb-2"></i><p>对话存档功能未初始化</p></div>';
                return;
            }
            
            const archives = window.conversationStorage.getAllArchives();
            
            // 调试信息
            console.log('获取到的存档数量:', archives.length);
            console.log('存档列表:', archives);
            
            if (archives.length === 0) {
                archiveList.innerHTML = '<div class="text-center py-8 text-slate-500 dark:text-slate-400"><i class="fa fa-folder-open-o text-4xl mb-2"></i><p>暂无对话存档</p></div>';
                return;
            }
            
            let html = '';
            archives.forEach(archive => {
                const date = new Date(archive.timestamp);
                html += `
                    <div class="archive-item bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg hover:bg-white/70 dark:hover:bg-slate-700/50 transition-colors cursor-pointer border border-slate-200 dark:border-slate-700">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex-1">
                                <h4 class="font-medium text-slate-800 dark:text-white truncate">${archive.name}</h4>
                                <p class="text-xs text-slate-500 dark:text-slate-400 mt-1">
                                    ${date.toLocaleString('zh-CN')} • ${archive.metadata.model}
                                </p>
                            </div>
                            <div class="flex gap-2 ml-2">
                                <button class="archive-action-btn text-xs px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors" data-action="use" data-id="${archive.id}">
                                    使用
                                </button>
                                <button class="archive-action-btn text-xs px-2 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition-colors" data-action="export" data-id="${archive.id}">
                                    导出
                                </button>
                                <button class="archive-action-btn text-xs px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition-colors" data-action="delete" data-id="${archive.id}">
                                    删除
                                </button>
                            </div>
                        </div>
                        <div class="text-xs text-slate-600 dark:text-slate-300 line-clamp-2">
                            ${archive.conversation.map(msg => `${msg.role}: ${msg.content.substring(0, 30)}...`).join(' • ')}
                        </div>
                    </div>
                `;
            });
            
            archiveList.innerHTML = html;
            
            // 添加存档操作事件
            archiveList.querySelectorAll('.archive-action-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const id = btn.dataset.id;
                    
                    if (action === 'use') {
                        useArchive(id);
                    } else if (action === 'export') {
                        exportArchive(id);
                    } else if (action === 'delete') {
                        deleteArchive(id);
                    }
                });
            });
            
            // 添加存档项点击事件（默认使用）
            archiveList.querySelectorAll('.archive-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = item.querySelector('.archive-action-btn[data-action="use"]').dataset.id;
                    useArchive(id);
                });
            });
        };
        
        // 使用存档
        const useArchive = (id) => {
            if (!window.conversationStorage) return;
            
            const archive = window.conversationStorage.getArchive(id);
            if (!archive) {
                alert('存档不存在或已被删除！');
                return;
            }
            
            // 清空现有对话
            container.innerHTML = '';
            conversationTurns = 0;
            
            // 导入对话
            archive.conversation.forEach(item => {
                if (item.role && item.content) {
                    addSingleTurn(item.role, item.content);
                }
            });
            
            // 保存到本地存储
            saveConversation();
            
            // 关闭模态框
            closeConversationManagerModal();
            
            alert('对话已加载！');
        };
        
        // 导出存档
        const exportArchive = (id) => {
            if (!window.conversationStorage) return;
            
            const success = window.conversationStorage.exportArchive(id);
            if (!success) {
                alert('导出存档失败！');
            }
        };
        
        // 删除存档
        const deleteArchive = (id) => {
            if (!window.conversationStorage) return;
            
            if (confirm('确定要删除这个对话存档吗？')) {
                const success = window.conversationStorage.deleteArchive(id);
                if (success) {
                    renderArchiveList();
                    alert('存档已删除！');
                } else {
                    alert('删除存档失败！');
                }
            }
        };
        
        // 打开对话管理模态框
        document.getElementById('conversation-manager').addEventListener('click', () => {
            const modal = document.getElementById('conversation-manager-modal');
            const modalContent = modal.querySelector('div');
            modal.classList.remove('hidden');
            // 添加过渡动画
            setTimeout(() => {
                modal.style.opacity = '1';
                modalContent.style.transform = 'scale(1)';
            }, 10);
            
            // 渲染对话存档列表
            renderArchiveList();
        });
        
        // 关闭对话管理模态框
        const closeConversationManagerModal = () => {
            const modal = document.getElementById('conversation-manager-modal');
            const modalContent = modal.querySelector('div');
            modal.style.opacity = '0';
            modalContent.style.transform = 'scale(0.95)';
            // 等待动画完成后隐藏
            setTimeout(() => {
                modal.classList.add('hidden');
                document.getElementById('import-json').value = '';
            }, 300);
        };
        
        document.getElementById('cancel-conversation-manager').addEventListener('click', closeConversationManagerModal);
        
        // 点击模态框外部关闭
        document.getElementById('conversation-manager-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeConversationManagerModal();
            }
        });
        
        // 标签页切换功能
        const switchTab = (tabId) => {
            // 切换标签样式
            document.querySelectorAll('#import-tab, #archive-tab').forEach(tab => {
                tab.classList.remove('text-klein-blue', 'dark:text-hermes-orange', 'border-b-2', 'border-klein-blue', 'dark:border-hermes-orange');
                tab.classList.add('text-slate-500', 'dark:text-slate-400');
            });
            
            document.getElementById(tabId).classList.remove('text-slate-500', 'dark:text-slate-400');
            document.getElementById(tabId).classList.add('text-klein-blue', 'dark:text-hermes-orange', 'border-b-2', 'border-klein-blue', 'dark:border-hermes-orange');
            
            // 切换面板
            document.getElementById('import-panel').classList.add('hidden');
            document.getElementById('archive-panel').classList.add('hidden');
            
            if (tabId === 'import-tab') {
                document.getElementById('import-panel').classList.remove('hidden');
                document.getElementById('confirm-conversation-manager').textContent = '导入';
            } else if (tabId === 'archive-tab') {
                document.getElementById('archive-panel').classList.remove('hidden');
                document.getElementById('confirm-conversation-manager').textContent = '使用';
            }
        };
        
        // 标签页点击事件
        document.getElementById('import-tab').addEventListener('click', () => {
            switchTab('import-tab');
        });
        
        document.getElementById('archive-tab').addEventListener('click', () => {
            switchTab('archive-tab');
        });
        
        // 刷新存档列表
        document.getElementById('refresh-archives').addEventListener('click', renderArchiveList);
        
        // 对话管理模态框确认按钮功能
        document.getElementById('confirm-conversation-manager').addEventListener('click', () => {
            const isImportTab = !document.getElementById('import-panel').classList.contains('hidden');
            
            if (isImportTab) {
                // 导入对话功能
                const jsonText = document.getElementById('import-json').value.trim();
                if (!jsonText) {
                    alert('请输入JSON格式的对话数据！');
                    return;
                }
                
                try {
                    const parsedData = JSON.parse(jsonText);
                    let conversationData;
                    
                    // 处理两种格式：直接对话数组或完整存档格式
                    if (Array.isArray(parsedData)) {
                        // 直接对话数组格式
                        conversationData = parsedData;
                    } else {
                        // 完整存档格式，提取conversation数组
                        if (!parsedData.conversation || !Array.isArray(parsedData.conversation)) {
                            throw new Error('无效的对话存档格式！');
                        }
                        conversationData = parsedData.conversation;
                    }
                    
                    // 保存到存档
                    if (window.conversationStorage) {
                        window.conversationStorage.importArchive(jsonText);
                    }
                    
                    // 清空现有对话
                    container.innerHTML = '';
                    conversationTurns = 0;
                    
                    // 导入对话
                    conversationData.forEach(item => {
                        if (item.role && item.content) {
                            addSingleTurn(item.role, item.content);
                        }
                    });
                    
                    // 保存到本地存储
                    saveConversation();
                    
                    // 关闭模态框
                    closeConversationManagerModal();
                    
                    alert('对话导入成功！');
                } catch (error) {
                    alert('导入失败：' + error.message);
                }
            } else {
                // 存档标签页，不执行任何操作（使用操作已在存档项点击事件中处理）
                closeConversationManagerModal();
            }
        });
        
        // 关于程序弹窗
        const aboutModal = `
            <div id="about-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center hidden transition-opacity duration-300 opacity-0">
                <div class="glass-effect dark:glass-effect-dark rounded-2xl p-6 max-w-2xl w-full mx-4 transform transition-transform duration-300 scale-95 max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-slate-900 dark:text-white flex items-center gap-2">
                            <i class="fa fa-info-circle text-klein-blue dark:text-hermes-orange"></i>
                            关于 YiziPaper AI对话模拟器
                        </h3>
                        <button id="close-about-modal" class="text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200 transition-colors duration-300">
                            <i class="fa fa-times text-lg"></i>
                        </button>
                    </div>
                    
                    <!-- 程序信息 -->
                    <div class="space-y-6">
                        <!-- 程序名称和版本 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white mb-2">程序信息</h4>
                            <p class="text-slate-700 dark:text-slate-300">
                                <strong>名称：</strong>YiziPaper AI对话模拟器<br>
                                <strong>版本：</strong>1.1.0<br>
                                <strong>更新日期：</strong>2025-12-3
                            </p>
                        </div>
                        
                        <!-- 开发由来 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white mb-2">为什么会有这么个模拟器？</h4>
                            <p class="text-slate-700 dark:text-slate-300 mb-2">&emsp;&emsp;作为一名AI写作开发者，我需要频繁测试不同模型、不同prompt以及不同上下文组合的AI写作效果。市面上的工具要么功能单一，要么操作繁琐，始终找不到趁手的测试工具。</p>
                            <p class="text-slate-700 dark:text-slate-300 mb-2">&emsp;&emsp;于是我决定用AI辅助编程（AI Coding）手搓一个：从需求分析到代码实现，全程与AI协作完成。这个小工具的最大特色是：基于纯HTML+JS本地运行，无需注册、无需云服务、完全开源，数据安全可控。</p>
                            <p class="text-slate-700 dark:text-slate-300">&emsp;&emsp;希望它能成为AI写作开发者的得力助手，让测试和调试变得更简单高效。</p>
                        </div>

                        <!-- 主要功能介绍 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white mb-2">主要功能</h4>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 space-y-1">
                                <li>创建和编辑多轮AI对话（用户、AI助手、系统角色）</li>
                                <li>支持多种AI模型提供商（包括智谱AI等）</li>
                                <li>生成AI回复和思维链（深度思考）</li>
                                <li>导出对话为JSON格式，用于大模型平台</li>
                                <li>自动保存和管理对话历史记录</li>
                                <li>支持对话存档的导入和导出</li>
                                <li>支持深色/浅色主题切换</li>
                            </ul>
                        </div>
                        
                        <!-- 使用方法 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white mb-2">使用方法</h4>
                            
                            <!-- 1. 对话编辑功能 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">1. 对话编辑功能</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>点击"添加对话轮次"按钮添加用户和AI对话各一条</li>
                                <li>点击头像切换角色（用户/AI助手/系统）</li>
                                <li>点击对话内容，自动展开文本框，编辑对话内容</li>
                                <li>对话展开后，侧边会显示操作按钮（删除、上移、下移、切换角色、编辑）</li>
                                <li>点击"导入对话"按钮，可以导入已有JSON格式对话列表[覆盖当前对话]</li>
                                <li>点击"清空所有对话"按钮，可以清空当前所有对话[无法撤销]</li>
                            </ul>
                            
                            <!-- 2. API设置功能 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">2. API设置功能</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>在API设置中选择AI模型提供商（支持火山方舟、阿里云百炼、OpenAI、Anthropic、Google Gemini、智谱AI）</li>
                                <li>选择具体模型（每个提供商提供多个模型可选）</li>
                                <li>输入API密钥并点击"保存API密钥"按钮</li>
                                <li>API密钥仅存储于本地浏览器缓存，请注意安全保管</li>
                                <li>如需增删厂商/大模型列表，请在外部文件model-config.js中修改</li>
                            </ul>
                            
                            <!-- 3. AI生成功能 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">3. AI生成功能</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>在左侧编辑好对话内容后，点击"AI生成"按钮生成AI回复</li>
                                <li>生成结果会显示在右侧预览区</li>
                                <li>支持"重新生成"和"清空结果"功能</li>
                                <li>生成结果可以直接插入到对话列表中</li>
                                <li>支持深度思考显示，可查看AI的思考过程</li>
                            </ul>
                            
                            <!-- 4. 预览和JSON生成功能 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">4. 预览和JSON生成功能</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>在右侧预览区可切换编辑模式和预览模式</li>
                                <li>编辑模式：直接编辑AI生成的Markdown内容</li>
                                <li>预览模式：渲染显示Markdown格式的生成结果</li>
                                <li>点击"生成JSON"按钮，将当前对话转换为JSON格式</li>
                                <li>生成的JSON可直接在大模型平台的对话框中粘贴使用</li>
                                <li>点击"复制到剪贴板"按钮，可复制生成的JSON</li>
                            </ul>
                            
                            <!-- 5. 历史记录管理功能 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">5. 历史记录管理功能</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>AI生成结果自动保存到本地历史记录中</li>
                                <li>最多可保存100条历史记录，超出自动清理旧记录</li>
                                <li>点击历史记录按钮，可查看、编辑、删除历史记录</li>
                                <li>支持将历史记录下载为Markdown格式文件</li>
                                <li>历史记录按时间顺序排列，便于查找</li>
                            </ul>
                            
                            <!-- 6. 对话管理功能 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">6. 对话管理功能</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>对话会自动保存为JSON格式到本地存储</li>
                                <li>最多可保存50个对话存档，每个存档包含模型和API提供商元数据</li>
                                <li>点击对话管理按钮，可查看、编辑、删除对话存档</li>
                                <li>支持对话存档的导出和导入功能，便于跨设备迁移</li>
                                <li>每个存档可自定义名称，便于区分不同对话场景</li>
                            </ul>
                            
                            <!-- 7. 主题和模式切换 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">7. 主题和模式切换</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>点击右上角的主题切换按钮，可切换浅色/深色主题</li>
                                <li>主题偏好会自动保存到本地存储</li>
                                <li>在AI预览区可切换编辑模式和预览模式</li>
                                <li>编辑模式适合直接修改内容，预览模式适合查看渲染效果</li>
                            </ul>
                            
                            <!-- 注意事项 -->
                            <h5 class="text-md font-bold text-slate-700 dark:text-slate-300 mt-3 mb-2">8. 注意事项</h5>
                            <ul class="list-disc list-inside text-slate-700 dark:text-slate-300 ml-2 space-y-1">
                                <li>删除对话操作无法撤销，请谨慎操作</li>
                                <li>API密钥仅存储于本地，不会上传到服务器</li>
                                <li>清空所有对话操作无法撤销，请谨慎操作</li>
                                <li>导入对话会覆盖当前所有对话，请提前备份</li>
                                <li>历史记录和对话存档仅存储于本地，建议定期导出备份</li>
                            </ul>
                        </div>
                        
                        <!-- 更新日志 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white mb-2">更新日志</h4>
                            <div class="text-slate-700 dark:text-slate-300 space-y-2">
                                <div>
                                    <strong>v1.1.0 (2025-12-03)</strong>
                                    <ul class="list-disc list-inside ml-4 mt-1 space-y-1">
                                        <li>新增智谱AI API接入，支持12个智谱AI模型（GLM-4.6、GLM-4.5等）</li>
                                        <li>实现AI生成历史记录保存功能，自动将生成结果保存到localStorage</li>
                                        <li>支持历史记录管理，包括查看、编辑、删除和下载历史记录（Markdown格式）</li>
                                        <li>最多可保存100条历史记录，超出自动清理旧记录</li>
                                        <li>新增对话管理功能，支持自动保存完整对话为JSON格式到localStorage</li>
                                        <li>支持对话存档的导出和导入功能，便于跨设备迁移</li>
                                        <li>最多可保存50个对话存档，每个存档包含模型和API提供商元数据</li>
                                        <li>优化垂直操作按钮定位，使其更贴近对话框，提升视觉体验</li>
                                        <li>修复不同角色下按钮对齐问题，确保所有角色按钮位置一致</li>
                                        <li>修复滚动条显示问题，实现默认隐藏、hover显示的优雅设计</li>
                                        <li>确保滚动条在直接打开HTML文件时也能正常工作</li>
                                        <li>统一所有区域滚动条样式，保持界面风格一致</li>
                                        <li>修复系统角色按钮定位问题，确保与其他角色保持一致</li>
                                        <li>优化按钮组显示逻辑，确保点击文本框时按钮平滑显示</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong>v1.0.0 (2025-11-30)</strong>
                                    <ul class="list-disc list-inside ml-4 mt-1 space-y-1">
                                        <li>初始版本发布</li>
                                        <li>支持多轮对话编辑</li>
                                        <li>支持多种AI模型提供商</li>
                                        <li>支持深度思考显示</li>
                                        <li>支持对话JSON导入导出</li>
                                        <li>支持深色/浅色主题切换</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 开发者信息 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-slate-800 dark:text-white mb-2">开发者信息</h4>
                            <p class="text-slate-700 dark:text-slate-300">
                                <strong>开发者：</strong>老独<br>
                                <strong>网站：</strong><a href="https://YiziPaper.com" target="_blank" class="text-blue-500 dark:text-blue-400 hover:underline">YiziPaper.com</a><br>
                                <strong>联系方式：</strong><a href="mailto:341812@qq.com" class="text-blue-500 dark:text-blue-400 hover:underline">341812@qq.com</a><br>
                                <strong>GitHub：</strong><a href="https://github.com/laoduu/YiziPaper-AI-Dialog-Builder" target="_blank" class="text-blue-500 dark:text-blue-400 hover:underline">YiziPaper-AI-Dialog-Builder</a>
                            </p>
                        </div>
                        
                        <!-- 版权信息 -->
                        <div class="bg-white/50 dark:bg-slate-800/50 p-4 rounded-lg text-center text-slate-700 dark:text-slate-300">
                            <p>© 2025 YiziPaper. All rights reserved.</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // 添加关于弹窗到页面
        document.body.insertAdjacentHTML('beforeend', aboutModal);
        
        // 右下角悬浮按钮
        const floatingBtn = `
            <button id="about-floating-btn" class="fixed bottom-6 right-6 w-12 h-12 rounded-full glass-effect dark:glass-effect-dark shadow-lg flex items-center justify-center text-klein-blue dark:text-hermes-orange hover:scale-110 transition-all duration-300 z-40">
                <i class="fa fa-info-circle text-xl"></i>
            </button>
        `;
        
        // 添加悬浮按钮到页面
        document.body.insertAdjacentHTML('beforeend', floatingBtn);
        
        // 等待DOM加载完成后初始化应用
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
